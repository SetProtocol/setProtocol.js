"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.SetUSDValuation={contractName:"SetUSDValuation",abi:[{constant:true,inputs:[],name:"SET_FULL_UNIT",outputs:[{name:"",type:"uint256"}],payable:false,stateMutability:"view",type:"function"}],metadata:'{"compiler":{"version":"0.5.7+commit.6da8b019"},"language":"Solidity","output":{"abi":[{"constant":true,"inputs":[],"name":"SET_FULL_UNIT","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"}],"devdoc":{"author":"Set Protocol * Utility functions to derive the USD value of a Set and its components","methods":{},"title":"SetUSDValuation"},"userdoc":{"methods":{}}},"settings":{"compilationTarget":{"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/liquidators/impl/SetUSDValuation.sol":"SetUSDValuation"},"evmVersion":"byzantium","libraries":{},"optimizer":{"enabled":true,"runs":200},"remappings":[]},"sources":{"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/interfaces/ICore.sol":{"keccak256":"0x5dc3db4398630ea52d2a40c9ddfa89d94e65c2770a12bab4d2a5c8eb573fb0a0","urls":["bzzr://25e90b53f61b388e0950b808e2296f82d427b66cfd6021212713436b2a592e31"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/interfaces/IFeeCalculator.sol":{"keccak256":"0xfdce9b333367bfed8f379738b0eabfe4be0045db735e9f24493de09729593d4d","urls":["bzzr://d2fa7438b492f4f08009810e3e9a2e2c22a429c307562e3f5274d4bfe2d21734"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/interfaces/ILiquidator.sol":{"keccak256":"0x9d1e66d56cd51d14787cce5ff8fb378eb6a0bb704e7102d7c4eda5de7f585af3","urls":["bzzr://c44220025ac21fda1dda68e236572c5c4f82bf53ccf504a020487b8c746c7b26"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/interfaces/IOracleWhiteList.sol":{"keccak256":"0xc4623b7082c6e017d1f820a05289a71d4262c01444ff1571e92f64a4e82662af","urls":["bzzr://c11cc5b2b50c5e708a09b10adf350e9ea3d3427cc2f199516db4ae9be498aaac"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/interfaces/IRebalancingSetToken.sol":{"keccak256":"0xe7356a7b0f0cc95d9526395d776f523a48fd65618730d67b4f31f20ffbd380da","urls":["bzzr://605a33a818eff7ce3370f25fccb751f61c066b4db0772605a2215d1357d68072"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/interfaces/IRebalancingSetTokenV2.sol":{"keccak256":"0x46c9dc7c09957eaa4f896b33d8d25ff5268e710172330f033379eed62a052ace","urls":["bzzr://c5b5cdc4e58c0905a03ef70954ac23eefe4776c243049f37e7b93cd8277bb7cb"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/interfaces/ISetToken.sol":{"keccak256":"0xfa6c0c07f8394d89b6b8f72e15778f8452a9341acb20cebb8421f3522aaca1bd","urls":["bzzr://ccf23bb78fd507bf8cbf5cf7ac2a660a1463b87a3689196e42b8f6862d1a6b11"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/lib/Rebalance.sol":{"keccak256":"0x74ffa689d93ced6c6e0377a35ec1274241b6191b5aaac5576ada379ac3840286","urls":["bzzr://25bdda3f1f5adfa2c83c760c44993d250cd2df037360f0018d22d268df79e887"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/lib/RebalancingLibrary.sol":{"keccak256":"0x7f9dd2f95b2ee71a98b94cb9b0df15874aa134e7480d04a1fcf36aff166a55f4","urls":["bzzr://f43a5563ec5df095151eee30cf7a0941b5a971917c27c7b34d9586b36563ab5b"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/lib/SetMath.sol":{"keccak256":"0x4c6762ad3d11c03889df48cc3b26bd199f958deffa651ec30655cd1654a47303","urls":["bzzr://b8e968dd2840d9586babe7852589abff3972135fff299285eaafd31687ae4385"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/liquidators/impl/SetUSDValuation.sol":{"keccak256":"0xb0b518c3a5f80e3f08df8157fb4dda48e1d48d2fa1c7149ee2e52bd21b1e8916","urls":["bzzr://b36893ff192fe43a9ed50161f5b616ed63b9fdeeb0b50b8512f19a84306380e0"]},"openzeppelin-solidity/contracts/math/Math.sol":{"keccak256":"0x775160984ceb0931bf67e718fb23afd6fc2a5d38a6e2378ebb438a039ed2269e","urls":["bzzr://209e27ad1c13e3e9b157915e0269ee4c3b6f0a494660dcc4acf1faf102e1a7ad"]},"openzeppelin-solidity/contracts/math/SafeMath.sol":{"keccak256":"0xc2a200a877c4a9b2475c246c54ffecc69ffde3e11af83319c63c2dc5458bac80","urls":["bzzr://c8876e2c39b60f155d748d71d715c8f3903fae5a405ac599adcb6ad2f9a583f9"]},"openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol":{"keccak256":"0xa60f7f7ce98ca2d75c8e02da982d3fe91176269fdab2589bbbb7cc65f2d7c9d3","urls":["bzzr://5edd2c9be304a1e8ed055e243daba5345f242008164f9a0565c33197b860323b"]},"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol":{"keccak256":"0x59e7df16169a498cb8837963b2f5461d88e63bd1eb6c7d58b814d76b84ccbe61","urls":["bzzr://e572c9c4e02e37349702451bf3b5dcbbc86a19da5a51695b5b3e1bfe1e7825dc"]},"set-protocol-contract-utils/contracts/lib/AddressArrayUtils.sol":{"keccak256":"0xb716eab4e8c5a336a2f19078928530829af097912bd1b925644f914b63601f08","urls":["bzzr://d8a21d39779beb316adb5180d08dcba1941eeccd9412ff08feb21a631c18c269"]},"set-protocol-oracles/contracts/meta-oracles/interfaces/IOracle.sol":{"keccak256":"0xeb5a447a0b1ef47547ce12a91b72412880edb9690aa9bcd8746fc3a379f2fbe9","urls":["bzzr://261675b916b84f58bea71ec28c4f711291053174ddf47e860c26daaee506744a"]}},"version":1}',bytecode:"0x60d6610025600b82828239805160001a60731461001857fe5b30600052607381538281f3fe7300000000000000000000000000000000000000003014608060405260043610604f577c01000000000000000000000000000000000000000000000000000000006000350463f3a4e2d881146054575b600080fd5b605a606e565b604051606591906087565b60405180910390f35b670de0b6b3a764000081565b6081816099565b82525050565b6020810160938284607a565b92915050565b9056fea265627a7a723058207a799b327a481fb6150409b625b7192f2da4c55903230c2166b829ef9567fdb66c6578706572696d656e74616cf50037",deployedBytecode:"0x7300000000000000000000000000000000000000003014608060405260043610604f577c01000000000000000000000000000000000000000000000000000000006000350463f3a4e2d881146054575b600080fd5b605a606e565b604051606591906087565b60405180910390f35b670de0b6b3a764000081565b6081816099565b82525050565b6020810160938284607a565b92915050565b9056fea265627a7a723058207a799b327a481fb6150409b625b7192f2da4c55903230c2166b829ef9567fdb66c6578706572696d656e74616cf50037",sourceMap:"1553:4041:54:-;;132:2:-1;166:7;155:9;146:7;137:37;255:7;249:14;246:1;241:23;235:4;232:33;222:2;;269:9;222:2;293:9;290:1;283:20;323:4;314:7;306:22;347:7;338;331:24",deployedSourceMap:"1553:4041:54:-;;;;;;;;;;;;;;;;;;;;;;;;1659:48;;;:::i;:::-;;;;;;;;;;;;;;;;;1699:8;1659:48;:::o;5:128:-1:-;96:31;121:5;96:31;;;91:3;84:44;78:55;;;140:229;266:2;251:18;;280:79;255:9;332:6;280:79;;;237:132;;;;;376:79;445:5;428:27",source:'/*\n    Copyright 2019 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.7;\npragma experimental "ABIEncoderV2";\n\nimport { ERC20Detailed } from "openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol";\nimport { Math } from "openzeppelin-solidity/contracts/math/Math.sol";\nimport { SafeMath } from "openzeppelin-solidity/contracts/math/SafeMath.sol";\nimport { AddressArrayUtils } from "set-protocol-contract-utils/contracts/lib/AddressArrayUtils.sol";\nimport { IOracle } from "set-protocol-oracles/contracts/meta-oracles/interfaces/IOracle.sol";\n\nimport { ICore } from "../../interfaces/ICore.sol";\nimport { IOracleWhiteList } from "../../interfaces/IOracleWhiteList.sol";\nimport { IRebalancingSetTokenV2 } from "../../interfaces/IRebalancingSetTokenV2.sol";\nimport { ISetToken } from "../../interfaces/ISetToken.sol";\nimport { SetMath } from "../../lib/SetMath.sol";\n\n\n/**\n * @title SetUSDValuation\n * @author Set Protocol\n *\n * Utility functions to derive the USD value of a Set and its components\n */\nlibrary SetUSDValuation {\n    using SafeMath for uint256;\n    using AddressArrayUtils for address[];\n\n    uint256 constant public SET_FULL_UNIT = 10 ** 18;\n\n    /* ============ SetToken Valuation Helpers ============ */\n\n\n    /**\n     * Calculates value of RebalancingSetToken.\n     *\n     * @return uint256        Streaming fee\n     */\n    function calculateRebalancingSetValue(\n        address _rebalancingSetTokenAddress,\n        IOracleWhiteList _oracleWhitelist\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        IRebalancingSetTokenV2 rebalancingSetToken = IRebalancingSetTokenV2(_rebalancingSetTokenAddress);\n\n        uint256 unitShares = rebalancingSetToken.unitShares();\n        uint256 naturalUnit = rebalancingSetToken.naturalUnit();\n        ISetToken currentSet = rebalancingSetToken.currentSet();\n\n        // Calculate collateral value\n        uint256 collateralValue = calculateSetTokenDollarValue(\n            currentSet,\n            _oracleWhitelist\n        );\n\n        // Value of rebalancing set is collateralValue times unitShares divided by naturalUnit\n        return collateralValue.mul(unitShares).div(naturalUnit);\n    }\n\n    /*\n     * Calculates the USD Value of a full unit Set Token\n     *\n     * @param  _set                 Instance of SetToken\n     * @param  _oracleWhiteList     Instance of oracle whitelist\n     * @return uint256              The USD value of the Set (in cents)\n     */\n    function calculateSetTokenDollarValue(\n        ISetToken _set,\n        IOracleWhiteList _oracleWhitelist\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 setDollarAmount = 0;\n\n        address[] memory components = _set.getComponents();\n        uint256[] memory units = _set.getUnits();\n        uint256 naturalUnit = _set.naturalUnit();\n\n        // Loop through assets\n        for (uint256 i = 0; i < components.length; i++) {\n            address currentComponent = components[i];\n\n            address oracle = _oracleWhitelist.getOracleAddressByToken(currentComponent);\n            uint256 price = IOracle(oracle).read();\n            uint256 decimals = ERC20Detailed(currentComponent).decimals();\n\n            // Calculate dollar value of single component in Set\n            uint256 tokenDollarValue = calculateTokenAllocationAmountUSD(\n                price,\n                naturalUnit,\n                units[i],\n                decimals\n            );\n\n            // Add value of single component to running component value tally\n            setDollarAmount = setDollarAmount.add(tokenDollarValue);\n        }\n\n        return setDollarAmount;\n    }\n\n    /*\n     * Get USD value of one component in a Set to 18 decimals\n     *\n     * @param  _tokenPrice          The 18 decimal value of one full token\n     * @param  _naturalUnit         The naturalUnit of the set being component belongs to\n     * @param  _unit                The unit of the component in the set\n     * @param  _tokenDecimal        The component token\'s decimal value\n     * @return uint256              The USD value of the component\'s allocation in the Set\n     */\n    function calculateTokenAllocationAmountUSD(\n        uint256 _tokenPrice,\n        uint256 _naturalUnit,\n        uint256 _unit,\n        uint256 _tokenDecimal\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 tokenFullUnit = 10 ** _tokenDecimal;\n\n        // Calculate the amount of component base units are in one full set token\n        uint256 componentUnitsInFullToken = SetMath.setToComponent(\n            SET_FULL_UNIT,\n            _unit,\n            _naturalUnit\n        );\n        \n        // Return value of component token in one full set token, to 18 decimals\n        uint256 allocationUSDValue = _tokenPrice\n            .mul(componentUnitsInFullToken)\n            .div(tokenFullUnit);\n\n        require(\n            allocationUSDValue > 0,\n            "SetUSDValuation.calculateTokenAllocationAmountUSD: Value must be > 0"\n        );\n\n        return allocationUSDValue;\n    }\n}',sourcePath:"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/liquidators/impl/SetUSDValuation.sol",compiler:{name:"solc",version:"0.5.7+commit.6da8b019.Linux.g++"},networks:{},schemaVersion:"3.0.23",updatedAt:"2020-05-05T17:13:36.507Z",devdoc:{author:"Set Protocol * Utility functions to derive the USD value of a Set and its components",methods:{},title:"SetUSDValuation"},userdoc:{methods:{}}};
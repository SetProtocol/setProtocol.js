"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.ZeroExOrderLibrary={contractName:"ZeroExOrderLibrary",abi:[],metadata:'{"compiler":{"version":"0.5.7+commit.6da8b019"},"language":"Solidity","output":{"abi":[],"devdoc":{"author":"Set Protocol * This library contains functions and structs to assist with parsing 0x wrapper order data * The layout of each wrapper order is in the table below. \\"ordersData\\" always refers to one or more byte strings, each containing all of these columns concatenated together. Each of the parse methods (header/body) below takes the entire ordersData along with an offset to parse the next (header/body) specified by the offset. This saves from having to do redudant memCopies to isolate the bytes containing the data to parse. * | Section | Data                  | Offset              | Length          | Contents                      | |---------|-----------------------|---------------------|-----------------|-------------------------------| | Header  | signatureLength       | 0                   | 32              | Num Bytes of 0x Signature     | |         | fillAmount            | 32                  | 64              | Taker asset fill amouint      | | Body    | signature             | 64                  | signatureLength | Signature in bytes            | |         | order                 | 64+signatureLength  | 384             | ZeroEx Order                  |","methods":{},"title":"ZeroExOrderLibrary"},"userdoc":{"methods":{}}},"settings":{"compilationTarget":{"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/exchange-wrappers/lib/ZeroExOrderLibrary.sol":"ZeroExOrderLibrary"},"evmVersion":"byzantium","libraries":{},"optimizer":{"enabled":true,"runs":200},"remappings":[]},"sources":{"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/exchange-wrappers/lib/ZeroExOrderLibrary.sol":{"keccak256":"0x7c25c61a156108bdb8761a2c44117991a808784735aca97f01102f70f40a6700","urls":["bzzr://b7945449829046699813a6223b07ae76fcfdc7ad5aea033bc66bdae25fd9e1ab"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/external/0x/Exchange/libs/LibEIP712.sol":{"keccak256":"0x16dc66e08199422c0bd0f2be5e0379b1b9403379d5f8ef823e9d911bce09fb81","urls":["bzzr://d4a8943b40e1395887e425628079d27cca609c6da2d72b9c3d07d3a56993f405"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/external/0x/Exchange/libs/LibOrder.sol":{"keccak256":"0x6b6a23c65daa2c2559575452593183394afd0b757e01e4ae25e32787b03c4158","urls":["bzzr://33c081a5303948e958cb95a5efd25415e0266ae2023c912977c6ee888798f4a5"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/external/0x/LibBytes.sol":{"keccak256":"0x8617740051ffe434ec5737fa1cf53fdd3c6dd901d6f8c3b379754d9928daa752","urls":["bzzr://52865a32d5c247782bf2fda7bb606c579caa924875108b96d7ea388ef19991fc"]},"openzeppelin-solidity/contracts/math/SafeMath.sol":{"keccak256":"0xc2a200a877c4a9b2475c246c54ffecc69ffde3e11af83319c63c2dc5458bac80","urls":["bzzr://c8876e2c39b60f155d748d71d715c8f3903fae5a405ac599adcb6ad2f9a583f9"]}},"version":1}',bytecode:"0x605a6023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a72305820e5b59538cf942bd8f174040f72f9e7daec4a45c4ad830c149c95541ee2ff2a346c6578706572696d656e74616cf50037",deployedBytecode:"0x73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a72305820e5b59538cf942bd8f174040f72f9e7daec4a45c4ad830c149c95541ee2ff2a346c6578706572696d656e74616cf50037",sourceMap:"2139:6294:6:-;;132:2:-1;166:7;155:9;146:7;137:37;255:7;249:14;246:1;241:23;235:4;232:33;222:2;;269:9;222:2;293:9;290:1;283:20;323:4;314:7;306:22;347:7;338;331:24",deployedSourceMap:"2139:6294:6:-;;;;;;;;",source:'/*\n    Copyright 2018 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.7;\npragma experimental "ABIEncoderV2";\n\nimport { SafeMath } from "openzeppelin-solidity/contracts/math/SafeMath.sol";\n\nimport { LibBytes } from "../../../external/0x/LibBytes.sol";\nimport { LibOrder } from "../../../external/0x/Exchange/libs/LibOrder.sol";\n\n\n/**\n * @title ZeroExOrderLibrary\n * @author Set Protocol\n *\n * This library contains functions and structs to assist with parsing 0x wrapper order data\n *\n * The layout of each wrapper order is in the table below. "ordersData" always refers to one or more byte strings,\n * each containing all of these columns concatenated together. Each of the parse methods (header/body) below takes\n * the entire ordersData along with an offset to parse the next (header/body) specified by the offset. This saves\n * from having to do redudant memCopies to isolate the bytes containing the data to parse.\n *\n * | Section | Data                  | Offset              | Length          | Contents                      |\n * |---------|-----------------------|---------------------|-----------------|-------------------------------|\n * | Header  | signatureLength       | 0                   | 32              | Num Bytes of 0x Signature     |\n * |         | fillAmount            | 32                  | 64              | Taker asset fill amouint      |\n * | Body    | signature             | 64                  | signatureLength | Signature in bytes            |\n * |         | order                 | 64+signatureLength  | 384             | ZeroEx Order                  |\n */\nlibrary ZeroExOrderLibrary {\n    using LibBytes for bytes;\n    using SafeMath for uint256;\n\n    // ============ Structs ============\n\n    struct OrderHeader {\n        uint256 signatureLength;\n        uint256 fillAmount;\n        bytes signature;\n    }\n\n    struct ZeroExOrderInformation {\n        OrderHeader header;\n        LibOrder.Order order;\n        address makerToken;\n        address takerToken;\n    }\n\n    // ============ Internal Functions ============\n\n    /*\n     * Parses the header from order byte array\n     * Can only be called by authorized contracts.\n     *\n     * @param  _ordersData   Byte array of order data\n     * @param  _offset       Offset to start scanning for order header\n     * @return OrderHeader   Struct containing wrapper order header data\n     */\n    function parseOrderHeader(\n        bytes memory _ordersData,\n        uint256 _offset\n    )\n        internal\n        pure\n        returns (OrderHeader memory)\n    {\n        OrderHeader memory header;\n\n        uint256 orderDataStart = _ordersData.contentAddress().add(_offset);\n\n        assembly {\n            mstore(header,           mload(orderDataStart))           // signatureLength\n            mstore(add(header, 32),  mload(add(orderDataStart, 32)))  // fillAmount\n        }\n\n        return header;\n    }\n\n    /*\n     * Parses the bytes array into ZeroEx order\n     *\n     * | Data                       | Location                      |\n     * |----------------------------|-------------------------------|\n     * | makerAddress               | 0                             |\n     * | takerAddress               | 32                            |\n     * | feeRecipientAddress        | 64                            |\n     * | senderAddress              | 96                            |\n     * | makerAssetAmount           | 128                           |\n     * | takerAssetAmount           | 160                           |\n     * | makerFee                   | 192                           |\n     * | takerFee                   | 224                           |\n     * | expirationTimeSeconds      | 256                           |\n     * | salt                       | 288                           |\n     * | makerToken                 | 320                           |\n     * | takerToken                 | 352                           |\n     *\n     * @param  _ordersData          Byte array of (multiple) 0x wrapper orders\n     * @param  _offset              Offset to start scanning for 0x order body\n     * @return LibOrder.Order       0x order struct\n     */\n    function parseZeroExOrder(\n        bytes memory _ordersData,\n        uint256 _offset\n    )\n        internal\n        pure\n        returns (LibOrder.Order memory)\n    {\n        LibOrder.Order memory order;\n        address makerTokenAddress;\n        address takerTokenAddress;\n\n        uint256 orderDataStart = _ordersData.contentAddress().add(_offset);\n\n        assembly {\n            mstore(order,           mload(orderDataStart))            // maker\n            mstore(add(order, 32),  mload(add(orderDataStart, 32)))   // taker\n            mstore(add(order, 64),  mload(add(orderDataStart, 64)))   // feeRecipient\n            mstore(add(order, 96),  mload(add(orderDataStart, 96)))   // senderAddress\n            mstore(add(order, 128), mload(add(orderDataStart, 128)))  // makerAssetAmount\n            mstore(add(order, 160), mload(add(orderDataStart, 160)))  // takerAssetAmount\n            mstore(add(order, 192), mload(add(orderDataStart, 192)))  // makerFee\n            mstore(add(order, 224), mload(add(orderDataStart, 224)))  // takerFee\n            mstore(add(order, 256), mload(add(orderDataStart, 256)))  // expirationUnixTimestampSec\n            mstore(add(order, 288), mload(add(orderDataStart, 288)))  // salt\n            makerTokenAddress := mload(add(orderDataStart, 320))      // makerToken\n            takerTokenAddress := mload(add(orderDataStart, 352))      // takerToken\n        }\n\n        order.makerAssetData = tokenAddressToAssetData(makerTokenAddress);\n        order.takerAssetData = tokenAddressToAssetData(takerTokenAddress);\n\n        return order;\n    }\n    /*\n     * Parses the maker token from the ZeroEx order\n     *\n     * @param  _ordersData          Byte array of (multiple) 0x wrapper orders\n     * @param  _offset              Offset to start scanning for 0x order body\n     * @return makerTokenAddress\n     */\n    function parseMakerTokenFromZeroExOrder(\n        bytes memory _ordersData,\n        uint256 _offset\n    )\n        internal\n        pure\n        returns (address)\n    {\n        address makerTokenAddress;\n\n        uint256 orderDataStart = _ordersData.contentAddress().add(_offset);\n\n        assembly {\n            makerTokenAddress := mload(add(orderDataStart, 320))      // makerToken\n        }\n\n        return makerTokenAddress;\n    }\n\n    /*\n     * Parses the taker token from the ZeroEx order\n     *\n     * @param  _ordersData          Byte array of (multiple) 0x wrapper orders\n     * @param  _offset              Offset to start scanning for 0x order body\n     * @return takerTokenAddress\n     */\n    function parseTakerTokenFromZeroExOrder(\n        bytes memory _ordersData,\n        uint256 _offset\n    )\n        internal\n        pure\n        returns (address)\n    {\n        address takerTokenAddress;\n\n        uint256 orderDataStart = _ordersData.contentAddress().add(_offset);\n\n        assembly {\n            takerTokenAddress := mload(add(orderDataStart, 352))      // takerToken\n        }\n\n        return takerTokenAddress;\n    }\n\n    /*\n     * Encodes an ERC20 token address into 0x asset data\n     *\n     * @param  _tokenAddress    Address of token to encode into 0x asset data\n     * @return bytes            0x asset data representation of a token\n     */\n    function tokenAddressToAssetData(\n        address _tokenAddress\n    )\n        private\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = new bytes(36);\n\n        // padded version of bytes4(keccak256("ERC20Token(address)"));\n        bytes32 selector = 0xf47261b000000000000000000000000000000000000000000000000000000000;\n\n        assembly {\n            mstore(add(result, 32), selector)\n            mstore(add(result, 36), _tokenAddress)\n        }\n\n        return result;\n    }\n}\n',sourcePath:"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/exchange-wrappers/lib/ZeroExOrderLibrary.sol",compiler:{name:"solc",version:"0.5.7+commit.6da8b019.Linux.g++"},networks:{},schemaVersion:"3.0.23",updatedAt:"2020-05-05T17:13:36.245Z",devdoc:{author:'Set Protocol * This library contains functions and structs to assist with parsing 0x wrapper order data * The layout of each wrapper order is in the table below. "ordersData" always refers to one or more byte strings, each containing all of these columns concatenated together. Each of the parse methods (header/body) below takes the entire ordersData along with an offset to parse the next (header/body) specified by the offset. This saves from having to do redudant memCopies to isolate the bytes containing the data to parse. * | Section | Data                  | Offset              | Length          | Contents                      | |---------|-----------------------|---------------------|-----------------|-------------------------------| | Header  | signatureLength       | 0                   | 32              | Num Bytes of 0x Signature     | |         | fillAmount            | 32                  | 64              | Taker asset fill amouint      | | Body    | signature             | 64                  | signatureLength | Signature in bytes            | |         | order                 | 64+signatureLength  | 384             | ZeroEx Order                  |',methods:{},title:"ZeroExOrderLibrary"},userdoc:{methods:{}}};
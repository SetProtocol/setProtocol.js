"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.RebalancingSetIssuance={contractName:"RebalancingSetIssuance",abi:[{constant:true,inputs:[],name:"vaultInstance",outputs:[{name:"",type:"address"}],payable:false,stateMutability:"view",type:"function"},{constant:true,inputs:[],name:"coreInstance",outputs:[{name:"",type:"address"}],payable:false,stateMutability:"view",type:"function"},{constant:true,inputs:[],name:"core",outputs:[{name:"",type:"address"}],payable:false,stateMutability:"view",type:"function"},{constant:true,inputs:[],name:"vault",outputs:[{name:"",type:"address"}],payable:false,stateMutability:"view",type:"function"}],metadata:'{"compiler":{"version":"0.5.7+commit.6da8b019"},"language":"Solidity","output":{"abi":[{"constant":true,"inputs":[],"name":"vaultInstance","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"coreInstance","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"core","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"vault","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"}],"devdoc":{"author":"Set Protocol * The RebalancingSetIssuance contains utility functions used in rebalancing SetToken  issuance","methods":{},"title":"RebalancingSetIssuance"},"userdoc":{"methods":{}}},"settings":{"compilationTarget":{"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/modules/lib/RebalancingSetIssuance.sol":"RebalancingSetIssuance"},"evmVersion":"byzantium","libraries":{},"optimizer":{"enabled":true,"runs":200},"remappings":[]},"sources":{"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/interfaces/ICore.sol":{"keccak256":"0x5dc3db4398630ea52d2a40c9ddfa89d94e65c2770a12bab4d2a5c8eb573fb0a0","urls":["bzzr://25e90b53f61b388e0950b808e2296f82d427b66cfd6021212713436b2a592e31"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/interfaces/IRebalancingSetToken.sol":{"keccak256":"0xe7356a7b0f0cc95d9526395d776f523a48fd65618730d67b4f31f20ffbd380da","urls":["bzzr://605a33a818eff7ce3370f25fccb751f61c066b4db0772605a2215d1357d68072"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/interfaces/ISetToken.sol":{"keccak256":"0xfa6c0c07f8394d89b6b8f72e15778f8452a9341acb20cebb8421f3522aaca1bd","urls":["bzzr://ccf23bb78fd507bf8cbf5cf7ac2a660a1463b87a3689196e42b8f6862d1a6b11"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/interfaces/ITransferProxy.sol":{"keccak256":"0x962d54385cc4760c550cd2f16bfdb53e967def4c5d3acb7b3d0b3d7a49f902de","urls":["bzzr://cb8994c8bae7fa1d55d240f44396f4156b45c81afa6fcfa608fd5e4bf9f1a919"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/interfaces/IVault.sol":{"keccak256":"0xf8a6d376173be39f5744492866db5dd3f91453a124d23679ff164ff3817f2f4f","urls":["bzzr://896c0a8329175c1620e1a22467778b835defe0e61847e5a8427a306f42391e64"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/lib/RebalancingLibrary.sol":{"keccak256":"0x7f9dd2f95b2ee71a98b94cb9b0df15874aa134e7480d04a1fcf36aff166a55f4","urls":["bzzr://f43a5563ec5df095151eee30cf7a0941b5a971917c27c7b34d9586b36563ab5b"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/modules/lib/ModuleCoreState.sol":{"keccak256":"0x75a216727092c78a7adb0016e4ed49bc174b4e8725b0e6b0689f86c4d20bcba7","urls":["bzzr://29bbd30e5a474c131c8ae83c00cf82f3bf2162e6f4699cb04f7c06507302e50c"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/modules/lib/RebalancingSetIssuance.sol":{"keccak256":"0x144cad20065c119f53eb5f68d55d9d225569773032345da965b1464a2fa4e334","urls":["bzzr://54bf1bafdf1a2db4732561aed72ffef0796c4512164d070a22465a53399ff374"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/lib/ERC20Wrapper.sol":{"keccak256":"0x09fdf2adbbcbe2ce6cf3924c8cae4e206cd501c3daca55d43c847d310150ceb8","urls":["bzzr://f2866ffe2b523888937071b65dd86d89a6e61161fd2d1ce1b9b52ea23914337d"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/lib/IERC20.sol":{"keccak256":"0xe4f71b1797f6421de91c6ce3b55199c5845693a58eddfd417a60b81d0198a9dd","urls":["bzzr://a6a4cebcffaff1db8ef9b78ea58d2d7391cc2b1ed533a1e1309286989f6d4ea0"]},"openzeppelin-solidity/contracts/math/SafeMath.sol":{"keccak256":"0xc2a200a877c4a9b2475c246c54ffecc69ffde3e11af83319c63c2dc5458bac80","urls":["bzzr://c8876e2c39b60f155d748d71d715c8f3903fae5a405ac599adcb6ad2f9a583f9"]},"set-protocol-contract-utils/contracts/lib/AddressArrayUtils.sol":{"keccak256":"0xb716eab4e8c5a336a2f19078928530829af097912bd1b925644f914b63601f08","urls":["bzzr://d8a21d39779beb316adb5180d08dcba1941eeccd9412ff08feb21a631c18c269"]},"set-protocol-contract-utils/contracts/lib/CommonMath.sol":{"keccak256":"0x3d1d08c6efc2a973fe2c02ddcb02fd99a8c8eb75f74dcbd93e8e15864eee2b6b","urls":["bzzr://580815dd1cf648a4521d923e59087de21143d9c48115ab71579a1f5a8f3d36af"]}},"version":1}',bytecode:"0x",deployedBytecode:"0x",sourceMap:"",deployedSourceMap:"",source:'/*\n    Copyright 2019 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.7;\n\nimport { SafeMath } from "openzeppelin-solidity/contracts/math/SafeMath.sol";\nimport { AddressArrayUtils } from "set-protocol-contract-utils/contracts/lib/AddressArrayUtils.sol";\n\nimport { ERC20Wrapper } from "../../../lib/ERC20Wrapper.sol";\nimport { IRebalancingSetToken } from "../../interfaces/IRebalancingSetToken.sol";\nimport { ISetToken } from "../../interfaces/ISetToken.sol";\nimport { ModuleCoreState } from "./ModuleCoreState.sol";\n\n\n/**\n * @title RebalancingSetIssuance\n * @author Set Protocol\n *\n * The RebalancingSetIssuance contains utility functions used in rebalancing SetToken \n * issuance\n */\ncontract RebalancingSetIssuance is \n    ModuleCoreState\n{\n    using SafeMath for uint256;\n    using AddressArrayUtils for address[];\n\n    // ============ Internal ============\n\n    /**\n     * Validates that wrapped Ether is a component of the SetToken\n     *\n     * @param  _setAddress            Address of the SetToken\n     * @param  _wrappedEtherAddress   Address of wrapped Ether\n     */\n    function validateWETHIsAComponentOfSet(\n        address _setAddress,\n        address _wrappedEtherAddress\n    )\n        internal\n        view\n    {\n        require(\n            ISetToken(_setAddress).tokenIsComponent(_wrappedEtherAddress),\n            "RebalancingSetIssuance.validateWETHIsAComponentOfSet: Components must contain weth"\n        );\n    }\n\n    /**\n     * Validates that the passed in address is tracked by Core and that the quantity\n     * is a multiple of the natural unit\n     *\n     * @param  _rebalancingSetAddress    Address of the rebalancing SetToken to issue/redeem\n     * @param  _rebalancingSetQuantity   The issuance quantity of rebalancing SetToken\n     */   \n    function validateRebalancingSetIssuance(\n        address _rebalancingSetAddress,\n        uint256 _rebalancingSetQuantity\n    ) \n        internal\n        view\n    {\n        // Expect rebalancing SetToken to be valid and enabled SetToken\n        require(\n            coreInstance.validSets(_rebalancingSetAddress),\n            "RebalancingSetIssuance.validateRebalancingIssuance: Invalid or disabled SetToken address"\n        );\n        \n        // Make sure Issuance quantity is multiple of the rebalancing SetToken natural unit\n        require(\n            _rebalancingSetQuantity.mod(ISetToken(_rebalancingSetAddress).naturalUnit()) == 0,\n            "RebalancingSetIssuance.validateRebalancingIssuance: Quantity must be multiple of natural unit"\n        );\n    }\n\n    /**\n     * Given a rebalancing SetToken and a desired issue quantity, calculates the \n     * minimum issuable quantity of the base SetToken. If the calculated quantity is initially\n     * not a multiple of the base SetToken\'s natural unit, the quantity is rounded up\n     * to the next base set natural unit.\n     *\n     * @param  _rebalancingSetAddress    Address of the rebalancing SetToken to issue\n     * @param  _rebalancingSetQuantity   The issuance quantity of rebalancing SetToken\n     * @return requiredBaseSetQuantity   The quantity of base SetToken to issue\n     */    \n    function getBaseSetIssuanceRequiredQuantity(\n        address _rebalancingSetAddress,\n        uint256 _rebalancingSetQuantity\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        IRebalancingSetToken rebalancingSet = IRebalancingSetToken(_rebalancingSetAddress);\n\n        uint256 unitShares = rebalancingSet.unitShares();\n        uint256 naturalUnit = rebalancingSet.naturalUnit();\n\n        uint256 requiredBaseSetQuantity = _rebalancingSetQuantity.div(naturalUnit).mul(unitShares);\n\n        address baseSet = rebalancingSet.currentSet();\n        uint256 baseSetNaturalUnit = ISetToken(baseSet).naturalUnit();\n\n        // If there is a mismatch between the required quantity and the base SetToken natural unit,\n        // round up to the next base SetToken natural unit if required.\n        uint256 roundDownQuantity = requiredBaseSetQuantity.mod(baseSetNaturalUnit);\n        if (roundDownQuantity > 0) {\n            requiredBaseSetQuantity = requiredBaseSetQuantity.sub(roundDownQuantity).add(baseSetNaturalUnit);\n        }\n\n        return requiredBaseSetQuantity;\n    }\n\n\n    /**\n     * Given a rebalancing SetToken address, retrieve the base SetToken quantity redeem quantity based on the quantity\n     * held in the Vault. Rounds down to the nearest base SetToken natural unit\n     *\n     * @param _baseSetAddress             The address of the base SetToken\n     * @return baseSetRedeemQuantity      The quantity of base SetToken to redeem\n     */\n    function getBaseSetRedeemQuantity(\n        address _baseSetAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        // Get base SetToken Details from the rebalancing SetToken\n        uint256 baseSetNaturalUnit = ISetToken(_baseSetAddress).naturalUnit();\n        uint256 baseSetBalance = vaultInstance.getOwnerBalance(\n            _baseSetAddress,\n            address(this)\n        );\n\n        // Round the balance down to the base SetToken natural unit and return\n        return baseSetBalance.sub(baseSetBalance.mod(baseSetNaturalUnit));\n    }\n\n    /**\n     * Checks the base SetToken balances in the Vault and on the contract. \n     * Sends any positive quantity to the user directly or into the Vault\n     * depending on the keepChangeInVault flag.\n     *\n     * @param _baseSetAddress             The address of the base SetToken\n     * @param _transferProxyAddress       The address of the TransferProxy\n     * @param  _keepChangeInVault         Boolean signifying whether excess base SetToken is transferred to the user \n     *                                     or left in the vault\n     */\n    function returnExcessBaseSet(\n        address _baseSetAddress,\n        address _transferProxyAddress,\n        bool _keepChangeInVault\n    )\n        internal\n    {\n        returnExcessBaseSetFromContract(_baseSetAddress, _transferProxyAddress, _keepChangeInVault);\n\n        returnExcessBaseSetInVault(_baseSetAddress, _keepChangeInVault);\n    }   \n\n    /**\n     * Checks the base SetToken balances on the contract and sends\n     * any positive quantity to the user directly or into the Vault\n     * depending on the keepChangeInVault flag.\n     *\n     * @param _baseSetAddress             The address of the base SetToken\n     * @param _transferProxyAddress       The address of the TransferProxy\n     * @param  _keepChangeInVault         Boolean signifying whether excess base SetToken is transfered to the user \n     *                                     or left in the vault\n     */\n    function returnExcessBaseSetFromContract(\n        address _baseSetAddress,\n        address _transferProxyAddress,\n        bool _keepChangeInVault\n    )\n        internal\n    {\n        uint256 baseSetQuantity = ERC20Wrapper.balanceOf(_baseSetAddress, address(this));\n        \n        if (baseSetQuantity == 0) { \n            return; \n        } else if (_keepChangeInVault) {\n            // Ensure base SetToken allowance\n            ERC20Wrapper.ensureAllowance(\n                _baseSetAddress,\n                address(this),\n                _transferProxyAddress,\n                baseSetQuantity\n            );\n\n            // Deposit base SetToken to the user\n            coreInstance.depositModule(\n                address(this),\n                msg.sender,\n                _baseSetAddress,\n                baseSetQuantity\n            );\n        } else {\n            // Transfer directly to the user\n            ERC20Wrapper.transfer(\n                _baseSetAddress,\n                msg.sender,\n                baseSetQuantity\n            );\n        }\n    }\n\n    /**\n     * Checks the base SetToken balances in the Vault and sends\n     * any positive quantity to the user directly or into the Vault\n     * depending on the keepChangeInVault flag.\n     *\n     * @param _baseSetAddress             The address of the base SetToken\n     * @param  _keepChangeInVault         Boolean signifying whether excess base SetToken is transfered to the user \n     *                                     or left in the vault\n     */\n    function returnExcessBaseSetInVault(\n        address _baseSetAddress,\n        bool _keepChangeInVault\n    )\n        internal\n    {\n        // Return base SetToken if any that are in the Vault\n        uint256 baseSetQuantityInVault = vaultInstance.getOwnerBalance(\n            _baseSetAddress,\n            address(this)\n        );\n        \n        if (baseSetQuantityInVault == 0) { \n            return; \n        } else if (_keepChangeInVault) {\n            // Transfer ownership within the vault to the user\n            coreInstance.internalTransfer(\n                _baseSetAddress,\n                msg.sender,\n                baseSetQuantityInVault\n            );\n        } else {\n            // Transfer ownership directly to the user\n            coreInstance.withdrawModule(\n                address(this),\n                msg.sender,\n                _baseSetAddress,\n                baseSetQuantityInVault\n            );\n        }\n    }   \n}\n',sourcePath:"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/modules/lib/RebalancingSetIssuance.sol",compiler:{name:"solc",version:"0.5.7+commit.6da8b019.Linux.g++"},networks:{},schemaVersion:"3.0.23",updatedAt:"2020-05-05T17:13:36.693Z",devdoc:{author:"Set Protocol * The RebalancingSetIssuance contains utility functions used in rebalancing SetToken  issuance",methods:{},title:"RebalancingSetIssuance"},userdoc:{methods:{}}};
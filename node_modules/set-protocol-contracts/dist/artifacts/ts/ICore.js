"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.ICore={contractName:"ICore",abi:[{constant:true,inputs:[],name:"transferProxy",outputs:[{name:"",type:"address"}],payable:false,stateMutability:"view",type:"function"},{constant:true,inputs:[],name:"vault",outputs:[{name:"",type:"address"}],payable:false,stateMutability:"view",type:"function"},{constant:true,inputs:[{name:"_exchangeId",type:"uint8"}],name:"exchangeIds",outputs:[{name:"",type:"address"}],payable:false,stateMutability:"view",type:"function"},{constant:true,inputs:[{name:"",type:"address"}],name:"validSets",outputs:[{name:"",type:"bool"}],payable:false,stateMutability:"view",type:"function"},{constant:true,inputs:[{name:"",type:"address"}],name:"validModules",outputs:[{name:"",type:"bool"}],payable:false,stateMutability:"view",type:"function"},{constant:true,inputs:[{name:"_priceLibrary",type:"address"}],name:"validPriceLibraries",outputs:[{name:"",type:"bool"}],payable:false,stateMutability:"view",type:"function"},{constant:false,inputs:[{name:"_set",type:"address"},{name:"_quantity",type:"uint256"}],name:"issue",outputs:[],payable:false,stateMutability:"nonpayable",type:"function"},{constant:false,inputs:[{name:"_recipient",type:"address"},{name:"_set",type:"address"},{name:"_quantity",type:"uint256"}],name:"issueTo",outputs:[],payable:false,stateMutability:"nonpayable",type:"function"},{constant:false,inputs:[{name:"_set",type:"address"},{name:"_quantity",type:"uint256"}],name:"issueInVault",outputs:[],payable:false,stateMutability:"nonpayable",type:"function"},{constant:false,inputs:[{name:"_set",type:"address"},{name:"_quantity",type:"uint256"}],name:"redeem",outputs:[],payable:false,stateMutability:"nonpayable",type:"function"},{constant:false,inputs:[{name:"_recipient",type:"address"},{name:"_set",type:"address"},{name:"_quantity",type:"uint256"}],name:"redeemTo",outputs:[],payable:false,stateMutability:"nonpayable",type:"function"},{constant:false,inputs:[{name:"_set",type:"address"},{name:"_quantity",type:"uint256"}],name:"redeemInVault",outputs:[],payable:false,stateMutability:"nonpayable",type:"function"},{constant:false,inputs:[{name:"_set",type:"address"},{name:"_to",type:"address"},{name:"_quantity",type:"uint256"},{name:"_toExclude",type:"uint256"}],name:"redeemAndWithdrawTo",outputs:[],payable:false,stateMutability:"nonpayable",type:"function"},{constant:false,inputs:[{name:"_tokens",type:"address[]"},{name:"_quantities",type:"uint256[]"}],name:"batchDeposit",outputs:[],payable:false,stateMutability:"nonpayable",type:"function"},{constant:false,inputs:[{name:"_tokens",type:"address[]"},{name:"_quantities",type:"uint256[]"}],name:"batchWithdraw",outputs:[],payable:false,stateMutability:"nonpayable",type:"function"},{constant:false,inputs:[{name:"_token",type:"address"},{name:"_quantity",type:"uint256"}],name:"deposit",outputs:[],payable:false,stateMutability:"nonpayable",type:"function"},{constant:false,inputs:[{name:"_token",type:"address"},{name:"_quantity",type:"uint256"}],name:"withdraw",outputs:[],payable:false,stateMutability:"nonpayable",type:"function"},{constant:false,inputs:[{name:"_token",type:"address"},{name:"_to",type:"address"},{name:"_quantity",type:"uint256"}],name:"internalTransfer",outputs:[],payable:false,stateMutability:"nonpayable",type:"function"},{constant:false,inputs:[{name:"_factory",type:"address"},{name:"_components",type:"address[]"},{name:"_units",type:"uint256[]"},{name:"_naturalUnit",type:"uint256"},{name:"_name",type:"bytes32"},{name:"_symbol",type:"bytes32"},{name:"_callData",type:"bytes"}],name:"createSet",outputs:[{name:"",type:"address"}],payable:false,stateMutability:"nonpayable",type:"function"},{constant:false,inputs:[{name:"_from",type:"address"},{name:"_to",type:"address"},{name:"_token",type:"address"},{name:"_quantity",type:"uint256"}],name:"depositModule",outputs:[],payable:false,stateMutability:"nonpayable",type:"function"},{constant:false,inputs:[{name:"_from",type:"address"},{name:"_to",type:"address"},{name:"_token",type:"address"},{name:"_quantity",type:"uint256"}],name:"withdrawModule",outputs:[],payable:false,stateMutability:"nonpayable",type:"function"},{constant:false,inputs:[{name:"_from",type:"address"},{name:"_to",type:"address"},{name:"_tokens",type:"address[]"},{name:"_quantities",type:"uint256[]"}],name:"batchDepositModule",outputs:[],payable:false,stateMutability:"nonpayable",type:"function"},{constant:false,inputs:[{name:"_from",type:"address"},{name:"_to",type:"address"},{name:"_tokens",type:"address[]"},{name:"_quantities",type:"uint256[]"}],name:"batchWithdrawModule",outputs:[],payable:false,stateMutability:"nonpayable",type:"function"},{constant:false,inputs:[{name:"_owner",type:"address"},{name:"_recipient",type:"address"},{name:"_set",type:"address"},{name:"_quantity",type:"uint256"}],name:"issueModule",outputs:[],payable:false,stateMutability:"nonpayable",type:"function"},{constant:false,inputs:[{name:"_burnAddress",type:"address"},{name:"_incrementAddress",type:"address"},{name:"_set",type:"address"},{name:"_quantity",type:"uint256"}],name:"redeemModule",outputs:[],payable:false,stateMutability:"nonpayable",type:"function"},{constant:false,inputs:[{name:"_tokens",type:"address[]"},{name:"_owner",type:"address"},{name:"_quantities",type:"uint256[]"}],name:"batchIncrementTokenOwnerModule",outputs:[],payable:false,stateMutability:"nonpayable",type:"function"},{constant:false,inputs:[{name:"_tokens",type:"address[]"},{name:"_owner",type:"address"},{name:"_quantities",type:"uint256[]"}],name:"batchDecrementTokenOwnerModule",outputs:[],payable:false,stateMutability:"nonpayable",type:"function"},{constant:false,inputs:[{name:"_tokens",type:"address[]"},{name:"_from",type:"address"},{name:"_to",type:"address"},{name:"_quantities",type:"uint256[]"}],name:"batchTransferBalanceModule",outputs:[],payable:false,stateMutability:"nonpayable",type:"function"},{constant:false,inputs:[{name:"_token",type:"address"},{name:"_quantity",type:"uint256"},{name:"_from",type:"address"},{name:"_to",type:"address"}],name:"transferModule",outputs:[],payable:false,stateMutability:"nonpayable",type:"function"},{constant:false,inputs:[{name:"_tokens",type:"address[]"},{name:"_quantities",type:"uint256[]"},{name:"_from",type:"address"},{name:"_to",type:"address"}],name:"batchTransferModule",outputs:[],payable:false,stateMutability:"nonpayable",type:"function"}],metadata:'{"compiler":{"version":"0.5.7+commit.6da8b019"},"language":"Solidity","output":{"abi":[{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_token","type":"address"},{"name":"_quantity","type":"uint256"}],"name":"withdrawModule","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_set","type":"address"},{"name":"_to","type":"address"},{"name":"_quantity","type":"uint256"},{"name":"_toExclude","type":"uint256"}],"name":"redeemAndWithdrawTo","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_set","type":"address"},{"name":"_quantity","type":"uint256"}],"name":"redeem","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_tokens","type":"address[]"},{"name":"_quantities","type":"uint256[]"}],"name":"batchDeposit","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_tokens","type":"address[]"},{"name":"_owner","type":"address"},{"name":"_quantities","type":"uint256[]"}],"name":"batchIncrementTokenOwnerModule","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_token","type":"address"},{"name":"_quantity","type":"uint256"}],"name":"deposit","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_tokens","type":"address[]"},{"name":"_quantities","type":"uint256[]"},{"name":"_from","type":"address"},{"name":"_to","type":"address"}],"name":"batchTransferModule","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_tokens","type":"address[]"},{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_quantities","type":"uint256[]"}],"name":"batchTransferBalanceModule","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_exchangeId","type":"uint8"}],"name":"exchangeIds","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_burnAddress","type":"address"},{"name":"_incrementAddress","type":"address"},{"name":"_set","type":"address"},{"name":"_quantity","type":"uint256"}],"name":"redeemModule","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_token","type":"address"},{"name":"_to","type":"address"},{"name":"_quantity","type":"uint256"}],"name":"internalTransfer","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_factory","type":"address"},{"name":"_components","type":"address[]"},{"name":"_units","type":"uint256[]"},{"name":"_naturalUnit","type":"uint256"},{"name":"_name","type":"bytes32"},{"name":"_symbol","type":"bytes32"},{"name":"_callData","type":"bytes"}],"name":"createSet","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"}],"name":"validModules","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"transferProxy","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_recipient","type":"address"},{"name":"_set","type":"address"},{"name":"_quantity","type":"uint256"}],"name":"issueTo","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_owner","type":"address"},{"name":"_recipient","type":"address"},{"name":"_set","type":"address"},{"name":"_quantity","type":"uint256"}],"name":"issueModule","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_set","type":"address"},{"name":"_quantity","type":"uint256"}],"name":"issue","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_priceLibrary","type":"address"}],"name":"validPriceLibraries","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_set","type":"address"},{"name":"_quantity","type":"uint256"}],"name":"issueInVault","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_set","type":"address"},{"name":"_quantity","type":"uint256"}],"name":"redeemInVault","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_tokens","type":"address[]"},{"name":"_owner","type":"address"},{"name":"_quantities","type":"uint256[]"}],"name":"batchDecrementTokenOwnerModule","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_tokens","type":"address[]"},{"name":"_quantities","type":"uint256[]"}],"name":"batchDepositModule","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_token","type":"address"},{"name":"_quantity","type":"uint256"}],"name":"depositModule","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_tokens","type":"address[]"},{"name":"_quantities","type":"uint256[]"}],"name":"batchWithdraw","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_recipient","type":"address"},{"name":"_set","type":"address"},{"name":"_quantity","type":"uint256"}],"name":"redeemTo","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_token","type":"address"},{"name":"_quantity","type":"uint256"}],"name":"withdraw","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"vault","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_token","type":"address"},{"name":"_quantity","type":"uint256"},{"name":"_from","type":"address"},{"name":"_to","type":"address"}],"name":"transferModule","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_tokens","type":"address[]"},{"name":"_quantities","type":"uint256[]"}],"name":"batchWithdrawModule","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"}],"name":"validSets","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"}],"devdoc":{"author":"Set Protocol * The ICore Contract defines all the functions exposed in the Core through its various extensions and is a light weight way to interact with the contract.","methods":{"batchDecrementTokenOwnerModule(address[],address,uint256[])":{"params":{"_owner":"The address of the token owner","_quantities":"The numbers of tokens to attribute to owner","_tokens":"The addresses of the ERC20 tokens"}},"batchDeposit(address[],uint256[])":{"params":{"_quantities":"Array of the number of tokens to deposit","_tokens":"Array of the addresses of the ERC20 tokens"}},"batchDepositModule(address,address,address[],uint256[])":{"params":{"_from":"Address to transfer tokens from","_quantities":"Array of the amounts of tokens to deposit","_to":"Address to credit for deposits","_tokens":"Array of the addresses of the tokens being deposited"}},"batchIncrementTokenOwnerModule(address[],address,uint256[])":{"params":{"_owner":"The address of the token owner","_quantities":"The numbers of tokens to attribute to owner","_tokens":"The addresses of the ERC20 tokens"}},"batchTransferBalanceModule(address[],address,address,uint256[])":{"params":{"_from":"Address tokens being transferred from","_quantities":"Amounts of tokens being transferred","_to":"Address tokens being transferred to","_tokens":"Addresses of tokens being transferred"}},"batchTransferModule(address[],uint256[],address,address)":{"params":{"_from":"The address to transfer from","_quantities":"The numbers of tokens to transfer","_to":"The address to transfer to","_tokens":"The addresses of the ERC20 token"}},"batchWithdraw(address[],uint256[])":{"params":{"_quantities":"Array of the number of tokens to withdraw","_tokens":"Array of the addresses of the ERC20 tokens"}},"batchWithdrawModule(address,address,address[],uint256[])":{"params":{"_from":"Address to decredit for withdrawals","_quantities":"Array of the amounts of tokens to withdraw","_to":"Address to transfer tokens to","_tokens":"Array of the addresses of the tokens being withdrawn"}},"createSet(address,address[],uint256[],uint256,bytes32,bytes32,bytes)":{"params":{"_callData":"Byte string containing additional call parameters","_components":"The address of component tokens","_factory":"The address of the Factory to create from","_name":"The bytes32 encoded name of the new Set","_naturalUnit":"The minimum unit to be issued or redeemed","_symbol":"The bytes32 encoded symbol of the new Set","_units":"The units of each component token"},"return":"setTokenAddress       The address of the new Set"},"deposit(address,uint256)":{"params":{"_quantity":"The number of tokens to deposit","_token":"The address of the ERC20 token"}},"depositModule(address,address,address,uint256)":{"params":{"_from":"Address to transfer tokens from","_quantity":"Amount of tokens to deposit","_to":"Address to credit for deposit","_token":"Address of token being deposited"}},"exchangeIds(uint8)":{"params":{"_exchangeId":"ExchangeId number"},"return":"address           Address belonging to given exchangeId"},"internalTransfer(address,address,uint256)":{"params":{"_quantity":"Amount of tokens being transferred","_to":"Address of user receiving tokens","_token":"Address of token being transferred"}},"issue(address,uint256)":{"params":{"_quantity":"Quantity of set to issue","_set":"Address of set to issue"}},"issueInVault(address,uint256)":{"params":{"_quantity":"Number of tokens to redeem","_set":"Address of the Set"}},"issueModule(address,address,address,uint256)":{"params":{"_owner":"Address to use tokens from","_quantity":"Number of tokens to issue","_recipient":"Address to issue Set to","_set":"Address of the Set to issue"}},"issueTo(address,address,uint256)":{"params":{"_quantity":"Number of tokens to issue","_recipient":"Address to issue to","_set":"Address of the Set to issue"}},"redeem(address,uint256)":{"params":{"_quantity":"The number of tokens to redeem. Should be multiple of natural unit.","_set":"The address of the Set token"}},"redeemAndWithdrawTo(address,address,uint256,uint256)":{"params":{"_quantity":"Number of tokens to redeem","_set":"Address of the Set","_to":"Address to withdraw or attribute tokens to","_toExclude":"Mask of indexes of tokens to exclude from withdrawing"}},"redeemInVault(address,uint256)":{"params":{"_quantity":"The number of tokens to redeem. Should be multiple of natural unit.","_set":"The address of the Set token"}},"redeemModule(address,address,address,uint256)":{"params":{"_burnAddress":"Address to burn token from","_incrementAddress":"Address to increment component tokens to","_quantity":"Number of tokens to redeem","_set":"Address of the Set to redeem"}},"redeemTo(address,address,uint256)":{"params":{"_quantity":"Number of tokens to redeem","_recipient":"Recipient of Set being issued","_set":"Address of the Set"}},"transferModule(address,uint256,address,address)":{"params":{"_from":"The address to transfer from","_quantity":"The number of tokens to transfer","_to":"The address to transfer to","_token":"The address of the ERC20 token"}},"transferProxy()":{"return":"address       transferProxy address"},"validPriceLibraries(address)":{"params":{"_priceLibrary":"Price library address"},"return":"bool             Boolean indicating if valid Price Library"},"vault()":{"return":"address       vault address"},"withdraw(address,uint256)":{"params":{"_quantity":"The number of tokens to withdraw","_token":"The address of the ERC20 token"}},"withdrawModule(address,address,address,uint256)":{"params":{"_from":"Address to decredit for withdraw","_quantity":"Amount of tokens to withdraw","_to":"Address to transfer tokens to","_token":"Address of token being withdrawn"}}},"title":"ICore"},"userdoc":{"methods":{"batchDecrementTokenOwnerModule(address[],address,uint256[])":{"notice":"Expose vault function that decrement user\'s balance in the vault Only available to system modules."},"batchDeposit(address[],uint256[])":{"notice":"Deposit multiple tokens to the vault. Quantities should be in the order of the addresses of the tokens being deposited."},"batchDepositModule(address,address,address[],uint256[])":{"notice":"Exposes internal function that deposits multiple tokens to the vault, to system modules. Quantities should be in the order of the addresses of the tokens being deposited."},"batchIncrementTokenOwnerModule(address[],address,uint256[])":{"notice":"Expose vault function that increments user\'s balance in the vault. Available to system modules"},"batchTransferBalanceModule(address[],address,address,uint256[])":{"notice":"Expose vault function that transfer vault balances between users Only available to system modules."},"batchTransferModule(address[],uint256[],address,address)":{"notice":"Expose transfer proxy function to transfer tokens from one address to another Only available to system modules."},"batchWithdraw(address[],uint256[])":{"notice":"Withdraw multiple tokens from the vault. Quantities should be in the order of the addresses of the tokens being withdrawn."},"batchWithdrawModule(address,address,address[],uint256[])":{"notice":"Exposes internal function that withdraws multiple tokens from the vault, to system modules. Quantities should be in the order of the addresses of the tokens being withdrawn."},"createSet(address,address[],uint256[],uint256,bytes32,bytes32,bytes)":{"notice":"Deploys a new Set Token and adds it to the valid list of SetTokens"},"deposit(address,uint256)":{"notice":"Deposit any quantity of tokens into the vault."},"depositModule(address,address,address,uint256)":{"notice":"Exposes internal function that deposits a quantity of tokens to the vault and attributes the tokens respectively, to system modules."},"exchangeIds(uint8)":{"notice":"Return address belonging to given exchangeId."},"internalTransfer(address,address,uint256)":{"notice":"Transfer tokens associated with the sender\'s account in vault to another user\'s account in vault."},"issue(address,uint256)":{"notice":"Exchanges components for Set Tokens"},"issueInVault(address,uint256)":{"notice":"Converts user\'s components into Set Tokens held directly in Vault instead of user\'s account"},"issueModule(address,address,address,uint256)":{"notice":"Expose internal function that exchanges components for Set tokens, accepting any owner, to system modules"},"issueTo(address,address,uint256)":{"notice":"Issues a specified Set for a specified quantity to the recipient using the caller\'s components from the wallet and vault."},"redeem(address,uint256)":{"notice":"Function to convert Set Tokens into underlying components"},"redeemAndWithdrawTo(address,address,uint256,uint256)":{"notice":"Composite method to redeem and withdraw with a single transaction     * Normally, you should expect to be able to withdraw all of the tokens. However, some have central abilities to freeze transfers (e.g. EOS). _toExclude allows you to optionally specify which component tokens to exclude when redeeming. They will remain in the vault under the users\' addresses."},"redeemInVault(address,uint256)":{"notice":"Function to convert Set Tokens held in vault into underlying components"},"redeemModule(address,address,address,uint256)":{"notice":"Expose internal function that exchanges Set tokens for components, accepting any owner, to system modules"},"redeemTo(address,address,uint256)":{"notice":"Redeem Set token and return components to specified recipient. The components are left in the vault"},"transferModule(address,uint256,address,address)":{"notice":"Transfers token from one address to another using the transfer proxy. Only available to system modules."},"transferProxy()":{"notice":"Return transferProxy address."},"validPriceLibraries(address)":{"notice":"Return boolean indicating if address is a valid Rebalancing Price Library."},"vault()":{"notice":"Return vault address."},"withdraw(address,uint256)":{"notice":"Withdraw a quantity of tokens from the vault."},"withdrawModule(address,address,address,uint256)":{"notice":"Exposes internal function that withdraws a quantity of tokens from the vault and deattributes the tokens respectively, to system modules."}}}},"settings":{"compilationTarget":{"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/interfaces/ICore.sol":"ICore"},"evmVersion":"byzantium","libraries":{},"optimizer":{"enabled":true,"runs":200},"remappings":[]},"sources":{"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/interfaces/ICore.sol":{"keccak256":"0x5dc3db4398630ea52d2a40c9ddfa89d94e65c2770a12bab4d2a5c8eb573fb0a0","urls":["bzzr://25e90b53f61b388e0950b808e2296f82d427b66cfd6021212713436b2a592e31"]}},"version":1}',bytecode:"0x",deployedBytecode:"0x",sourceMap:"",deployedSourceMap:"",source:"/*\n    Copyright 2018 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.7;\n\n\n/**\n * @title ICore\n * @author Set Protocol\n *\n * The ICore Contract defines all the functions exposed in the Core through its\n * various extensions and is a light weight way to interact with the contract.\n */\ninterface ICore {\n    /**\n     * Return transferProxy address.\n     *\n     * @return address       transferProxy address\n     */\n    function transferProxy()\n        external\n        view\n        returns (address);\n\n    /**\n     * Return vault address.\n     *\n     * @return address       vault address\n     */\n    function vault()\n        external\n        view\n        returns (address);\n\n    /**\n     * Return address belonging to given exchangeId.\n     *\n     * @param  _exchangeId       ExchangeId number\n     * @return address           Address belonging to given exchangeId\n     */\n    function exchangeIds(\n        uint8 _exchangeId\n    )\n        external\n        view\n        returns (address);\n\n    /*\n     * Returns if valid set\n     *\n     * @return  bool      Returns true if Set created through Core and isn't disabled\n     */\n    function validSets(address)\n        external\n        view\n        returns (bool);\n\n    /*\n     * Returns if valid module\n     *\n     * @return  bool      Returns true if valid module\n     */\n    function validModules(address)\n        external\n        view\n        returns (bool);\n\n    /**\n     * Return boolean indicating if address is a valid Rebalancing Price Library.\n     *\n     * @param  _priceLibrary    Price library address\n     * @return bool             Boolean indicating if valid Price Library\n     */\n    function validPriceLibraries(\n        address _priceLibrary\n    )\n        external\n        view\n        returns (bool);\n\n    /**\n     * Exchanges components for Set Tokens\n     *\n     * @param  _set          Address of set to issue\n     * @param  _quantity     Quantity of set to issue\n     */\n    function issue(\n        address _set,\n        uint256 _quantity\n    )\n        external;\n\n    /**\n     * Issues a specified Set for a specified quantity to the recipient\n     * using the caller's components from the wallet and vault.\n     *\n     * @param  _recipient    Address to issue to\n     * @param  _set          Address of the Set to issue\n     * @param  _quantity     Number of tokens to issue\n     */\n    function issueTo(\n        address _recipient,\n        address _set,\n        uint256 _quantity\n    )\n        external;\n\n    /**\n     * Converts user's components into Set Tokens held directly in Vault instead of user's account\n     *\n     * @param _set          Address of the Set\n     * @param _quantity     Number of tokens to redeem\n     */\n    function issueInVault(\n        address _set,\n        uint256 _quantity\n    )\n        external;\n\n    /**\n     * Function to convert Set Tokens into underlying components\n     *\n     * @param _set          The address of the Set token\n     * @param _quantity     The number of tokens to redeem. Should be multiple of natural unit.\n     */\n    function redeem(\n        address _set,\n        uint256 _quantity\n    )\n        external;\n\n    /**\n     * Redeem Set token and return components to specified recipient. The components\n     * are left in the vault\n     *\n     * @param _recipient    Recipient of Set being issued\n     * @param _set          Address of the Set\n     * @param _quantity     Number of tokens to redeem\n     */\n    function redeemTo(\n        address _recipient,\n        address _set,\n        uint256 _quantity\n    )\n        external;\n\n    /**\n     * Function to convert Set Tokens held in vault into underlying components\n     *\n     * @param _set          The address of the Set token\n     * @param _quantity     The number of tokens to redeem. Should be multiple of natural unit.\n     */\n    function redeemInVault(\n        address _set,\n        uint256 _quantity\n    )\n        external;\n\n    /**\n     * Composite method to redeem and withdraw with a single transaction\n     *\n     * Normally, you should expect to be able to withdraw all of the tokens.\n     * However, some have central abilities to freeze transfers (e.g. EOS). _toExclude\n     * allows you to optionally specify which component tokens to exclude when\n     * redeeming. They will remain in the vault under the users' addresses.\n     *\n     * @param _set          Address of the Set\n     * @param _to           Address to withdraw or attribute tokens to\n     * @param _quantity     Number of tokens to redeem\n     * @param _toExclude    Mask of indexes of tokens to exclude from withdrawing\n     */\n    function redeemAndWithdrawTo(\n        address _set,\n        address _to,\n        uint256 _quantity,\n        uint256 _toExclude\n    )\n        external;\n\n    /**\n     * Deposit multiple tokens to the vault. Quantities should be in the\n     * order of the addresses of the tokens being deposited.\n     *\n     * @param  _tokens           Array of the addresses of the ERC20 tokens\n     * @param  _quantities       Array of the number of tokens to deposit\n     */\n    function batchDeposit(\n        address[] calldata _tokens,\n        uint256[] calldata _quantities\n    )\n        external;\n\n    /**\n     * Withdraw multiple tokens from the vault. Quantities should be in the\n     * order of the addresses of the tokens being withdrawn.\n     *\n     * @param  _tokens            Array of the addresses of the ERC20 tokens\n     * @param  _quantities        Array of the number of tokens to withdraw\n     */\n    function batchWithdraw(\n        address[] calldata _tokens,\n        uint256[] calldata _quantities\n    )\n        external;\n\n    /**\n     * Deposit any quantity of tokens into the vault.\n     *\n     * @param  _token           The address of the ERC20 token\n     * @param  _quantity        The number of tokens to deposit\n     */\n    function deposit(\n        address _token,\n        uint256 _quantity\n    )\n        external;\n\n    /**\n     * Withdraw a quantity of tokens from the vault.\n     *\n     * @param  _token           The address of the ERC20 token\n     * @param  _quantity        The number of tokens to withdraw\n     */\n    function withdraw(\n        address _token,\n        uint256 _quantity\n    )\n        external;\n\n    /**\n     * Transfer tokens associated with the sender's account in vault to another user's\n     * account in vault.\n     *\n     * @param  _token           Address of token being transferred\n     * @param  _to              Address of user receiving tokens\n     * @param  _quantity        Amount of tokens being transferred\n     */\n    function internalTransfer(\n        address _token,\n        address _to,\n        uint256 _quantity\n    )\n        external;\n\n    /**\n     * Deploys a new Set Token and adds it to the valid list of SetTokens\n     *\n     * @param  _factory              The address of the Factory to create from\n     * @param  _components           The address of component tokens\n     * @param  _units                The units of each component token\n     * @param  _naturalUnit          The minimum unit to be issued or redeemed\n     * @param  _name                 The bytes32 encoded name of the new Set\n     * @param  _symbol               The bytes32 encoded symbol of the new Set\n     * @param  _callData             Byte string containing additional call parameters\n     * @return setTokenAddress       The address of the new Set\n     */\n    function createSet(\n        address _factory,\n        address[] calldata _components,\n        uint256[] calldata _units,\n        uint256 _naturalUnit,\n        bytes32 _name,\n        bytes32 _symbol,\n        bytes calldata _callData\n    )\n        external\n        returns (address);\n\n    /**\n     * Exposes internal function that deposits a quantity of tokens to the vault and attributes\n     * the tokens respectively, to system modules.\n     *\n     * @param  _from            Address to transfer tokens from\n     * @param  _to              Address to credit for deposit\n     * @param  _token           Address of token being deposited\n     * @param  _quantity        Amount of tokens to deposit\n     */\n    function depositModule(\n        address _from,\n        address _to,\n        address _token,\n        uint256 _quantity\n    )\n        external;\n\n    /**\n     * Exposes internal function that withdraws a quantity of tokens from the vault and\n     * deattributes the tokens respectively, to system modules.\n     *\n     * @param  _from            Address to decredit for withdraw\n     * @param  _to              Address to transfer tokens to\n     * @param  _token           Address of token being withdrawn\n     * @param  _quantity        Amount of tokens to withdraw\n     */\n    function withdrawModule(\n        address _from,\n        address _to,\n        address _token,\n        uint256 _quantity\n    )\n        external;\n\n    /**\n     * Exposes internal function that deposits multiple tokens to the vault, to system\n     * modules. Quantities should be in the order of the addresses of the tokens being\n     * deposited.\n     *\n     * @param  _from              Address to transfer tokens from\n     * @param  _to                Address to credit for deposits\n     * @param  _tokens            Array of the addresses of the tokens being deposited\n     * @param  _quantities        Array of the amounts of tokens to deposit\n     */\n    function batchDepositModule(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _quantities\n    )\n        external;\n\n    /**\n     * Exposes internal function that withdraws multiple tokens from the vault, to system\n     * modules. Quantities should be in the order of the addresses of the tokens being withdrawn.\n     *\n     * @param  _from              Address to decredit for withdrawals\n     * @param  _to                Address to transfer tokens to\n     * @param  _tokens            Array of the addresses of the tokens being withdrawn\n     * @param  _quantities        Array of the amounts of tokens to withdraw\n     */\n    function batchWithdrawModule(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _quantities\n    )\n        external;\n\n    /**\n     * Expose internal function that exchanges components for Set tokens,\n     * accepting any owner, to system modules\n     *\n     * @param  _owner        Address to use tokens from\n     * @param  _recipient    Address to issue Set to\n     * @param  _set          Address of the Set to issue\n     * @param  _quantity     Number of tokens to issue\n     */\n    function issueModule(\n        address _owner,\n        address _recipient,\n        address _set,\n        uint256 _quantity\n    )\n        external;\n\n    /**\n     * Expose internal function that exchanges Set tokens for components,\n     * accepting any owner, to system modules\n     *\n     * @param  _burnAddress         Address to burn token from\n     * @param  _incrementAddress    Address to increment component tokens to\n     * @param  _set                 Address of the Set to redeem\n     * @param  _quantity            Number of tokens to redeem\n     */\n    function redeemModule(\n        address _burnAddress,\n        address _incrementAddress,\n        address _set,\n        uint256 _quantity\n    )\n        external;\n\n    /**\n     * Expose vault function that increments user's balance in the vault.\n     * Available to system modules\n     *\n     * @param  _tokens          The addresses of the ERC20 tokens\n     * @param  _owner           The address of the token owner\n     * @param  _quantities      The numbers of tokens to attribute to owner\n     */\n    function batchIncrementTokenOwnerModule(\n        address[] calldata _tokens,\n        address _owner,\n        uint256[] calldata _quantities\n    )\n        external;\n\n    /**\n     * Expose vault function that decrement user's balance in the vault\n     * Only available to system modules.\n     *\n     * @param  _tokens          The addresses of the ERC20 tokens\n     * @param  _owner           The address of the token owner\n     * @param  _quantities      The numbers of tokens to attribute to owner\n     */\n    function batchDecrementTokenOwnerModule(\n        address[] calldata _tokens,\n        address _owner,\n        uint256[] calldata _quantities\n    )\n        external;\n\n    /**\n     * Expose vault function that transfer vault balances between users\n     * Only available to system modules.\n     *\n     * @param  _tokens           Addresses of tokens being transferred\n     * @param  _from             Address tokens being transferred from\n     * @param  _to               Address tokens being transferred to\n     * @param  _quantities       Amounts of tokens being transferred\n     */\n    function batchTransferBalanceModule(\n        address[] calldata _tokens,\n        address _from,\n        address _to,\n        uint256[] calldata _quantities\n    )\n        external;\n\n    /**\n     * Transfers token from one address to another using the transfer proxy.\n     * Only available to system modules.\n     *\n     * @param  _token          The address of the ERC20 token\n     * @param  _quantity       The number of tokens to transfer\n     * @param  _from           The address to transfer from\n     * @param  _to             The address to transfer to\n     */\n    function transferModule(\n        address _token,\n        uint256 _quantity,\n        address _from,\n        address _to\n    )\n        external;\n\n    /**\n     * Expose transfer proxy function to transfer tokens from one address to another\n     * Only available to system modules.\n     *\n     * @param  _tokens         The addresses of the ERC20 token\n     * @param  _quantities     The numbers of tokens to transfer\n     * @param  _from           The address to transfer from\n     * @param  _to             The address to transfer to\n     */\n    function batchTransferModule(\n        address[] calldata _tokens,\n        uint256[] calldata _quantities,\n        address _from,\n        address _to\n    )\n        external;\n}\n",
sourcePath:"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/interfaces/ICore.sol",compiler:{name:"solc",version:"0.5.7+commit.6da8b019.Linux.g++"},networks:{},schemaVersion:"3.0.23",updatedAt:"2020-05-05T17:13:36.337Z",devdoc:{author:"Set Protocol * The ICore Contract defines all the functions exposed in the Core through its various extensions and is a light weight way to interact with the contract.",methods:{"batchDecrementTokenOwnerModule(address[],address,uint256[])":{params:{_owner:"The address of the token owner",_quantities:"The numbers of tokens to attribute to owner",_tokens:"The addresses of the ERC20 tokens"}},"batchDeposit(address[],uint256[])":{params:{_quantities:"Array of the number of tokens to deposit",_tokens:"Array of the addresses of the ERC20 tokens"}},"batchDepositModule(address,address,address[],uint256[])":{params:{_from:"Address to transfer tokens from",_quantities:"Array of the amounts of tokens to deposit",_to:"Address to credit for deposits",_tokens:"Array of the addresses of the tokens being deposited"}},"batchIncrementTokenOwnerModule(address[],address,uint256[])":{params:{_owner:"The address of the token owner",_quantities:"The numbers of tokens to attribute to owner",_tokens:"The addresses of the ERC20 tokens"}},"batchTransferBalanceModule(address[],address,address,uint256[])":{params:{_from:"Address tokens being transferred from",_quantities:"Amounts of tokens being transferred",_to:"Address tokens being transferred to",_tokens:"Addresses of tokens being transferred"}},"batchTransferModule(address[],uint256[],address,address)":{params:{_from:"The address to transfer from",_quantities:"The numbers of tokens to transfer",_to:"The address to transfer to",_tokens:"The addresses of the ERC20 token"}},"batchWithdraw(address[],uint256[])":{params:{_quantities:"Array of the number of tokens to withdraw",_tokens:"Array of the addresses of the ERC20 tokens"}},"batchWithdrawModule(address,address,address[],uint256[])":{params:{_from:"Address to decredit for withdrawals",_quantities:"Array of the amounts of tokens to withdraw",_to:"Address to transfer tokens to",_tokens:"Array of the addresses of the tokens being withdrawn"}},"createSet(address,address[],uint256[],uint256,bytes32,bytes32,bytes)":{params:{_callData:"Byte string containing additional call parameters",_components:"The address of component tokens",_factory:"The address of the Factory to create from",_name:"The bytes32 encoded name of the new Set",_naturalUnit:"The minimum unit to be issued or redeemed",_symbol:"The bytes32 encoded symbol of the new Set",_units:"The units of each component token"},"return":"setTokenAddress       The address of the new Set"},"deposit(address,uint256)":{params:{_quantity:"The number of tokens to deposit",_token:"The address of the ERC20 token"}},"depositModule(address,address,address,uint256)":{params:{_from:"Address to transfer tokens from",_quantity:"Amount of tokens to deposit",_to:"Address to credit for deposit",_token:"Address of token being deposited"}},"exchangeIds(uint8)":{params:{_exchangeId:"ExchangeId number"},"return":"address           Address belonging to given exchangeId"},"internalTransfer(address,address,uint256)":{params:{_quantity:"Amount of tokens being transferred",_to:"Address of user receiving tokens",_token:"Address of token being transferred"}},"issue(address,uint256)":{params:{_quantity:"Quantity of set to issue",_set:"Address of set to issue"}},"issueInVault(address,uint256)":{params:{_quantity:"Number of tokens to redeem",_set:"Address of the Set"}},"issueModule(address,address,address,uint256)":{params:{_owner:"Address to use tokens from",_quantity:"Number of tokens to issue",_recipient:"Address to issue Set to",_set:"Address of the Set to issue"}},"issueTo(address,address,uint256)":{params:{_quantity:"Number of tokens to issue",_recipient:"Address to issue to",_set:"Address of the Set to issue"}},"redeem(address,uint256)":{params:{_quantity:"The number of tokens to redeem. Should be multiple of natural unit.",_set:"The address of the Set token"}},"redeemAndWithdrawTo(address,address,uint256,uint256)":{params:{_quantity:"Number of tokens to redeem",_set:"Address of the Set",_to:"Address to withdraw or attribute tokens to",_toExclude:"Mask of indexes of tokens to exclude from withdrawing"}},"redeemInVault(address,uint256)":{params:{_quantity:"The number of tokens to redeem. Should be multiple of natural unit.",_set:"The address of the Set token"}},"redeemModule(address,address,address,uint256)":{params:{_burnAddress:"Address to burn token from",_incrementAddress:"Address to increment component tokens to",_quantity:"Number of tokens to redeem",_set:"Address of the Set to redeem"}},"redeemTo(address,address,uint256)":{params:{_quantity:"Number of tokens to redeem",_recipient:"Recipient of Set being issued",_set:"Address of the Set"}},"transferModule(address,uint256,address,address)":{params:{_from:"The address to transfer from",_quantity:"The number of tokens to transfer",_to:"The address to transfer to",_token:"The address of the ERC20 token"}},"transferProxy()":{"return":"address       transferProxy address"},"validPriceLibraries(address)":{params:{_priceLibrary:"Price library address"},"return":"bool             Boolean indicating if valid Price Library"},"vault()":{"return":"address       vault address"},"withdraw(address,uint256)":{params:{_quantity:"The number of tokens to withdraw",_token:"The address of the ERC20 token"}},"withdrawModule(address,address,address,uint256)":{params:{_from:"Address to decredit for withdraw",_quantity:"Amount of tokens to withdraw",_to:"Address to transfer tokens to",_token:"Address of token being withdrawn"}}},title:"ICore"},userdoc:{methods:{"batchDecrementTokenOwnerModule(address[],address,uint256[])":{notice:"Expose vault function that decrement user's balance in the vault Only available to system modules."},"batchDeposit(address[],uint256[])":{notice:"Deposit multiple tokens to the vault. Quantities should be in the order of the addresses of the tokens being deposited."},"batchDepositModule(address,address,address[],uint256[])":{notice:"Exposes internal function that deposits multiple tokens to the vault, to system modules. Quantities should be in the order of the addresses of the tokens being deposited."},"batchIncrementTokenOwnerModule(address[],address,uint256[])":{notice:"Expose vault function that increments user's balance in the vault. Available to system modules"},"batchTransferBalanceModule(address[],address,address,uint256[])":{notice:"Expose vault function that transfer vault balances between users Only available to system modules."},"batchTransferModule(address[],uint256[],address,address)":{notice:"Expose transfer proxy function to transfer tokens from one address to another Only available to system modules."},"batchWithdraw(address[],uint256[])":{notice:"Withdraw multiple tokens from the vault. Quantities should be in the order of the addresses of the tokens being withdrawn."},"batchWithdrawModule(address,address,address[],uint256[])":{notice:"Exposes internal function that withdraws multiple tokens from the vault, to system modules. Quantities should be in the order of the addresses of the tokens being withdrawn."},"createSet(address,address[],uint256[],uint256,bytes32,bytes32,bytes)":{notice:"Deploys a new Set Token and adds it to the valid list of SetTokens"},"deposit(address,uint256)":{notice:"Deposit any quantity of tokens into the vault."},"depositModule(address,address,address,uint256)":{notice:"Exposes internal function that deposits a quantity of tokens to the vault and attributes the tokens respectively, to system modules."},"exchangeIds(uint8)":{notice:"Return address belonging to given exchangeId."},"internalTransfer(address,address,uint256)":{notice:"Transfer tokens associated with the sender's account in vault to another user's account in vault."},"issue(address,uint256)":{notice:"Exchanges components for Set Tokens"},"issueInVault(address,uint256)":{notice:"Converts user's components into Set Tokens held directly in Vault instead of user's account"},"issueModule(address,address,address,uint256)":{notice:"Expose internal function that exchanges components for Set tokens, accepting any owner, to system modules"},"issueTo(address,address,uint256)":{notice:"Issues a specified Set for a specified quantity to the recipient using the caller's components from the wallet and vault."},"redeem(address,uint256)":{notice:"Function to convert Set Tokens into underlying components"},"redeemAndWithdrawTo(address,address,uint256,uint256)":{notice:"Composite method to redeem and withdraw with a single transaction     * Normally, you should expect to be able to withdraw all of the tokens. However, some have central abilities to freeze transfers (e.g. EOS). _toExclude allows you to optionally specify which component tokens to exclude when redeeming. They will remain in the vault under the users' addresses."},"redeemInVault(address,uint256)":{notice:"Function to convert Set Tokens held in vault into underlying components"},"redeemModule(address,address,address,uint256)":{notice:"Expose internal function that exchanges Set tokens for components, accepting any owner, to system modules"},"redeemTo(address,address,uint256)":{notice:"Redeem Set token and return components to specified recipient. The components are left in the vault"},"transferModule(address,uint256,address,address)":{notice:"Transfers token from one address to another using the transfer proxy. Only available to system modules."},"transferProxy()":{notice:"Return transferProxy address."},"validPriceLibraries(address)":{notice:"Return boolean indicating if address is a valid Rebalancing Price Library."},"vault()":{notice:"Return vault address."},"withdraw(address,uint256)":{notice:"Withdraw a quantity of tokens from the vault."},"withdrawModule(address,address,address,uint256)":{notice:"Exposes internal function that withdraws a quantity of tokens from the vault and deattributes the tokens respectively, to system modules."}}}};
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.TokenFlush={contractName:"TokenFlush",abi:[{constant:true,inputs:[],name:"transferProxyInstance",outputs:[{name:"",type:"address"}],payable:false,stateMutability:"view",type:"function"},{constant:true,inputs:[],name:"vaultInstance",outputs:[{name:"",type:"address"}],payable:false,stateMutability:"view",type:"function"},{constant:true,inputs:[],name:"coreInstance",outputs:[{name:"",type:"address"}],payable:false,stateMutability:"view",type:"function"}],metadata:'{"compiler":{"version":"0.5.7+commit.6da8b019"},"language":"Solidity","output":{"abi":[{"constant":true,"inputs":[],"name":"transferProxyInstance","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"vaultInstance","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"coreInstance","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"}],"devdoc":{"author":"Set Protocol * The TokenFlush contains utility functions to send tokens and base SetTokens from the Vault or Contract to a specified user address","methods":{},"title":"TokenFlush"},"userdoc":{"methods":{}}},"settings":{"compilationTarget":{"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/modules/lib/TokenFlush.sol":"TokenFlush"},"evmVersion":"byzantium","libraries":{},"optimizer":{"enabled":true,"runs":200},"remappings":[]},"sources":{"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/interfaces/ICore.sol":{"keccak256":"0x5dc3db4398630ea52d2a40c9ddfa89d94e65c2770a12bab4d2a5c8eb573fb0a0","urls":["bzzr://25e90b53f61b388e0950b808e2296f82d427b66cfd6021212713436b2a592e31"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/interfaces/ISetToken.sol":{"keccak256":"0xfa6c0c07f8394d89b6b8f72e15778f8452a9341acb20cebb8421f3522aaca1bd","urls":["bzzr://ccf23bb78fd507bf8cbf5cf7ac2a660a1463b87a3689196e42b8f6862d1a6b11"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/interfaces/ITransferProxy.sol":{"keccak256":"0x962d54385cc4760c550cd2f16bfdb53e967def4c5d3acb7b3d0b3d7a49f902de","urls":["bzzr://cb8994c8bae7fa1d55d240f44396f4156b45c81afa6fcfa608fd5e4bf9f1a919"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/interfaces/IVault.sol":{"keccak256":"0xf8a6d376173be39f5744492866db5dd3f91453a124d23679ff164ff3817f2f4f","urls":["bzzr://896c0a8329175c1620e1a22467778b835defe0e61847e5a8427a306f42391e64"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/modules/lib/ModuleCoreStateV2.sol":{"keccak256":"0x5abe818b7be8b89413a09d1a46f3fa45215d6c9635a7e1863a7adcb4c81563d5","urls":["bzzr://6dca336b9478019098670ae4e3dc7a8e768e2a5f2f7b3c5bbdd2927d05c255bc"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/modules/lib/TokenFlush.sol":{"keccak256":"0x12cd831f2b3369dfe70462afb47b236f8d2ea2887c277eede5f8318d01edf1f2","urls":["bzzr://cd7ae65bc2bacfadba6789a78467d9f2e27e79ae05e6cd9071a8918b3db9c953"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/lib/ERC20Wrapper.sol":{"keccak256":"0x09fdf2adbbcbe2ce6cf3924c8cae4e206cd501c3daca55d43c847d310150ceb8","urls":["bzzr://f2866ffe2b523888937071b65dd86d89a6e61161fd2d1ce1b9b52ea23914337d"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/lib/IERC20.sol":{"keccak256":"0xe4f71b1797f6421de91c6ce3b55199c5845693a58eddfd417a60b81d0198a9dd","urls":["bzzr://a6a4cebcffaff1db8ef9b78ea58d2d7391cc2b1ed533a1e1309286989f6d4ea0"]},"openzeppelin-solidity/contracts/math/SafeMath.sol":{"keccak256":"0xc2a200a877c4a9b2475c246c54ffecc69ffde3e11af83319c63c2dc5458bac80","urls":["bzzr://c8876e2c39b60f155d748d71d715c8f3903fae5a405ac599adcb6ad2f9a583f9"]},"set-protocol-contract-utils/contracts/lib/AddressArrayUtils.sol":{"keccak256":"0xb716eab4e8c5a336a2f19078928530829af097912bd1b925644f914b63601f08","urls":["bzzr://d8a21d39779beb316adb5180d08dcba1941eeccd9412ff08feb21a631c18c269"]},"set-protocol-contract-utils/contracts/lib/CommonMath.sol":{"keccak256":"0x3d1d08c6efc2a973fe2c02ddcb02fd99a8c8eb75f74dcbd93e8e15864eee2b6b","urls":["bzzr://580815dd1cf648a4521d923e59087de21143d9c48115ab71579a1f5a8f3d36af"]}},"version":1}',bytecode:"0x",deployedBytecode:"0x",sourceMap:"",deployedSourceMap:"",source:'/*\n    Copyright 2019 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.7;\n\nimport { SafeMath } from "openzeppelin-solidity/contracts/math/SafeMath.sol";\nimport { AddressArrayUtils } from "set-protocol-contract-utils/contracts/lib/AddressArrayUtils.sol";\n\nimport { ERC20Wrapper } from "../../../lib/ERC20Wrapper.sol";\nimport { ISetToken } from "../../interfaces/ISetToken.sol";\nimport { ModuleCoreStateV2 } from "./ModuleCoreStateV2.sol";\n\n\n/**\n * @title TokenFlush\n * @author Set Protocol\n *\n * The TokenFlush contains utility functions to send tokens and base SetTokens from the\n * Vault or Contract to a specified user address\n */\ncontract TokenFlush is \n    ModuleCoreStateV2\n{\n    using SafeMath for uint256;\n    using AddressArrayUtils for address[];\n\n    // ============ Internal ============\n\n    /**\n     * Checks the base SetToken balances on the contract and sends\n     * any positive quantity to the user directly or into the Vault\n     * depending on the keepChangeInVault flag.\n     *\n     * @param _baseSetAddress             The address of the base SetToken\n     * @param _returnAddress              The address to send excess tokens to\n     * @param  _keepChangeInVault         Boolean signifying whether excess base SetToken is transfered to the user \n     *                                     or left in the vault\n     */\n    function returnExcessBaseSetFromContract(\n        address _baseSetAddress,\n        address _returnAddress,\n        bool _keepChangeInVault\n    )\n        internal\n    {\n        uint256 baseSetQuantity = ERC20Wrapper.balanceOf(_baseSetAddress, address(this));\n        \n        if (baseSetQuantity > 0) { \n            if (_keepChangeInVault) {\n                // Ensure base SetToken allowance\n                ERC20Wrapper.ensureAllowance(\n                    _baseSetAddress,\n                    address(this),\n                    address(transferProxyInstance),\n                    baseSetQuantity\n                );\n\n                // Deposit base SetToken to the user\n                coreInstance.depositModule(\n                    address(this),\n                    _returnAddress,\n                    _baseSetAddress,\n                    baseSetQuantity\n                );\n            } else {\n                // Transfer directly to the user\n                ERC20Wrapper.transfer(\n                    _baseSetAddress,\n                    _returnAddress,\n                    baseSetQuantity\n                );\n            }\n        }\n    }\n\n    /**\n     * Checks the base SetToken balances in the Vault and sends\n     * any positive quantity to the user directly or into the Vault\n     * depending on the keepChangeInVault flag.\n     *\n     * @param _baseSetAddress             The address of the base SetToken\n     * @param _returnAddress              The address to send excess tokens to\n     * @param  _keepChangeInVault         Boolean signifying whether excess base SetToken is transfered to the user \n     *                                     or left in the vault\n     */\n    function returnExcessBaseSetInVault(\n        address _baseSetAddress,\n        address _returnAddress,\n        bool _keepChangeInVault\n    )\n        internal\n    {\n        // Return base SetToken if any that are in the Vault\n        uint256 baseSetQuantityInVault = vaultInstance.getOwnerBalance(\n            _baseSetAddress,\n            address(this)\n        );\n        \n        if (baseSetQuantityInVault > 0) { \n            if (_keepChangeInVault) {\n                // Transfer ownership within the vault to the user\n                coreInstance.internalTransfer(\n                    _baseSetAddress,\n                    _returnAddress,\n                    baseSetQuantityInVault\n                );\n            } else {\n                // Transfer ownership directly to the user\n                coreInstance.withdrawModule(\n                    address(this),\n                    _returnAddress,\n                    _baseSetAddress,\n                    baseSetQuantityInVault\n                );\n            }\n        }\n    } \n\n    /**\n     * Withdraw any base Set components to the user from the contract.\n     *\n     * @param _baseSetToken               Instance of the Base SetToken\n     * @param _returnAddress              The address to send excess tokens to\n     */\n    function returnExcessComponentsFromContract(\n        ISetToken _baseSetToken,\n        address _returnAddress\n    )\n        internal\n    {\n        // Return base Set components\n        address[] memory baseSetComponents = _baseSetToken.getComponents();\n        for (uint256 i = 0; i < baseSetComponents.length; i++) {\n            uint256 withdrawQuantity = ERC20Wrapper.balanceOf(baseSetComponents[i], address(this));\n            if (withdrawQuantity > 0) {\n                ERC20Wrapper.transfer(\n                    baseSetComponents[i],\n                    _returnAddress,\n                    withdrawQuantity\n                );\n            }\n        }         \n    }\n\n    /**\n     * Any base Set components in the Vault are returned to the caller.\n     *\n     * @param _baseSetToken               Instance of the Base SetToken\n     * @param _returnAddress              The address to send excess tokens to\n     */\n    function returnExcessComponentsFromVault(\n        ISetToken _baseSetToken,\n        address _returnAddress\n    )\n        internal\n    {\n        // Return base Set components not used in issuance of base set\n        address[] memory baseSetComponents = _baseSetToken.getComponents();\n        for (uint256 i = 0; i < baseSetComponents.length; i++) {\n            uint256 vaultQuantity = vaultInstance.getOwnerBalance(baseSetComponents[i], address(this));\n            if (vaultQuantity > 0) {\n                coreInstance.withdrawModule(\n                    address(this),\n                    _returnAddress,\n                    baseSetComponents[i],\n                    vaultQuantity\n                );\n            }\n        }\n    }   \n}\n',sourcePath:"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/modules/lib/TokenFlush.sol",compiler:{name:"solc",version:"0.5.7+commit.6da8b019.Linux.g++"},networks:{},schemaVersion:"3.0.23",updatedAt:"2020-05-05T17:13:36.742Z",devdoc:{author:"Set Protocol * The TokenFlush contains utility functions to send tokens and base SetTokens from the Vault or Contract to a specified user address",methods:{},title:"TokenFlush"},userdoc:{methods:{}}};
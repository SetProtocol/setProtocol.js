"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.ReentrancyGuard={contractName:"ReentrancyGuard",abi:[{inputs:[],payable:false,stateMutability:"nonpayable",type:"constructor"}],metadata:'{"compiler":{"version":"0.5.7+commit.6da8b019"},"language":"Solidity","output":{"abi":[{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"}],"devdoc":{"author":"Remco Bloemen <remco@2\\u03c0.com>, Eenae <alexey@mixbytes.io>","details":"If you mark a function `nonReentrant`, you should also mark it `external`.","methods":{},"title":"Helps contracts guard against reentrancy attacks."},"userdoc":{"methods":{}}},"settings":{"compilationTarget":{"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol":"ReentrancyGuard"},"evmVersion":"byzantium","libraries":{},"optimizer":{"enabled":true,"runs":200},"remappings":[]},"sources":{"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol":{"keccak256":"0x080fa336eb92fca1f96bf5c7738b6ef6e23582809d81868e9498c08e1207c125","urls":["bzzr://3bc299fd722679f1313dc1387e2efc0591dcddc3727b6a7ccc98132c6e02f323"]}},"version":1}',bytecode:"0x",deployedBytecode:"0x",sourceMap:"",deployedSourceMap:"",source:"pragma solidity ^0.5.2;\n\n/**\n * @title Helps contracts guard against reentrancy attacks.\n * @author Remco Bloemen <remco@2π.com>, Eenae <alexey@mixbytes.io>\n * @dev If you mark a function `nonReentrant`, you should also\n * mark it `external`.\n */\ncontract ReentrancyGuard {\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    constructor () internal {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter);\n    }\n}\n",sourcePath:"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol",compiler:{name:"solc",version:"0.5.7+commit.6da8b019.Linux.g++"},networks:{},schemaVersion:"3.0.23",updatedAt:"2020-05-05T17:13:37.160Z",devdoc:{author:"Remco Bloemen <remco@2π.com>, Eenae <alexey@mixbytes.io>",details:"If you mark a function `nonReentrant`, you should also mark it `external`.",methods:{},title:"Helps contracts guard against reentrancy attacks."},userdoc:{methods:{}}};
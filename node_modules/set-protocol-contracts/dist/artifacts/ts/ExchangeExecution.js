"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.ExchangeExecution={contractName:"ExchangeExecution",abi:[{constant:true,inputs:[],name:"vaultInstance",outputs:[{name:"",type:"address"}],payable:false,stateMutability:"view",type:"function"},{constant:true,inputs:[],name:"coreInstance",outputs:[{name:"",type:"address"}],payable:false,stateMutability:"view",type:"function"},{constant:true,inputs:[],name:"core",outputs:[{name:"",type:"address"}],payable:false,stateMutability:"view",type:"function"},{constant:true,inputs:[],name:"vault",outputs:[{name:"",type:"address"}],payable:false,stateMutability:"view",type:"function"}],metadata:'{"compiler":{"version":"0.5.7+commit.6da8b019"},"language":"Solidity","output":{"abi":[{"constant":true,"inputs":[],"name":"vaultInstance","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"coreInstance","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"core","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"vault","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"}],"devdoc":{"author":"Set Protocol * The ExchangeExecution contract exposes functions that allow validation and execution of exchange orders.","methods":{},"title":"ExchangeExecution"},"userdoc":{"methods":{}}},"settings":{"compilationTarget":{"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/modules/lib/ExchangeExecution.sol":"ExchangeExecution"},"evmVersion":"byzantium","libraries":{},"optimizer":{"enabled":true,"runs":200},"remappings":[]},"sources":{"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/interfaces/ICore.sol":{"keccak256":"0x5dc3db4398630ea52d2a40c9ddfa89d94e65c2770a12bab4d2a5c8eb573fb0a0","urls":["bzzr://25e90b53f61b388e0950b808e2296f82d427b66cfd6021212713436b2a592e31"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/interfaces/IExchangeWrapper.sol":{"keccak256":"0xbe6c55b4ddd26e1fcda74a09c5202f1c938a23edc3cbe6328780bd8eb05e7fde","urls":["bzzr://fdba29705c0defefa87e4102dc401125a4df8ac76f06555718e39365f316810f"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/interfaces/ISetToken.sol":{"keccak256":"0xfa6c0c07f8394d89b6b8f72e15778f8452a9341acb20cebb8421f3522aaca1bd","urls":["bzzr://ccf23bb78fd507bf8cbf5cf7ac2a660a1463b87a3689196e42b8f6862d1a6b11"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/interfaces/ITransferProxy.sol":{"keccak256":"0x962d54385cc4760c550cd2f16bfdb53e967def4c5d3acb7b3d0b3d7a49f902de","urls":["bzzr://cb8994c8bae7fa1d55d240f44396f4156b45c81afa6fcfa608fd5e4bf9f1a919"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/interfaces/IVault.sol":{"keccak256":"0xf8a6d376173be39f5744492866db5dd3f91453a124d23679ff164ff3817f2f4f","urls":["bzzr://896c0a8329175c1620e1a22467778b835defe0e61847e5a8427a306f42391e64"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/lib/ExchangeHeaderLibrary.sol":{"keccak256":"0x58b3405fe4aab096766b34705ec80d87085180110e21aba02cce2e6ea507d808","urls":["bzzr://0b6941c5bdb138ebe0080bbe5f6c43e56878e0bc30ff3c2461f0e3b53b8a6113"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/lib/ExchangeWrapperLibrary.sol":{"keccak256":"0xcf95f40c291b1d8fb9adab6e0896f91bb8f2f6397d24e741ab82aab1192d3930","urls":["bzzr://3c75694fc0cbc623a02f7db596ffc72c64f8f662624101b87e390c0578407aaf"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/lib/ExchangeWrapperLibraryV2.sol":{"keccak256":"0x92acd5054efb89467456183e7086e6022f9aed0c2044d00aeab382bcc8c86c4f","urls":["bzzr://92084a7a6cc58333b93b929171cdf455cec92ae314dd8c7f082778f0bd825e54"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/modules/lib/ExchangeExecution.sol":{"keccak256":"0x5ba2bf0b1fbbde60920d522a0632a1bc1233c910a012ba653a4d2d223a1972c3","urls":["bzzr://45d664915f179c68857a0045ad32c8ce494f7644b903fd0f59a32061e6a0c020"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/modules/lib/ExchangeIssuanceLibrary.sol":{"keccak256":"0xad04bacfe5bb25a8cb0ca84f3a406e9c10a45e75c13ebdf24f27801399b2cbeb","urls":["bzzr://f6a28d02f730cfb64f3082d7cb2780cbb07c8939648f7466d21eae21defa6367"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/modules/lib/ModuleCoreState.sol":{"keccak256":"0x75a216727092c78a7adb0016e4ed49bc174b4e8725b0e6b0689f86c4d20bcba7","urls":["bzzr://29bbd30e5a474c131c8ae83c00cf82f3bf2162e6f4699cb04f7c06507302e50c"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/external/0x/LibBytes.sol":{"keccak256":"0x8617740051ffe434ec5737fa1cf53fdd3c6dd901d6f8c3b379754d9928daa752","urls":["bzzr://52865a32d5c247782bf2fda7bb606c579caa924875108b96d7ea388ef19991fc"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/lib/ERC20Wrapper.sol":{"keccak256":"0x09fdf2adbbcbe2ce6cf3924c8cae4e206cd501c3daca55d43c847d310150ceb8","urls":["bzzr://f2866ffe2b523888937071b65dd86d89a6e61161fd2d1ce1b9b52ea23914337d"]},"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/lib/IERC20.sol":{"keccak256":"0xe4f71b1797f6421de91c6ce3b55199c5845693a58eddfd417a60b81d0198a9dd","urls":["bzzr://a6a4cebcffaff1db8ef9b78ea58d2d7391cc2b1ed533a1e1309286989f6d4ea0"]},"openzeppelin-solidity/contracts/math/SafeMath.sol":{"keccak256":"0xc2a200a877c4a9b2475c246c54ffecc69ffde3e11af83319c63c2dc5458bac80","urls":["bzzr://c8876e2c39b60f155d748d71d715c8f3903fae5a405ac599adcb6ad2f9a583f9"]},"set-protocol-contract-utils/contracts/lib/AddressArrayUtils.sol":{"keccak256":"0xb716eab4e8c5a336a2f19078928530829af097912bd1b925644f914b63601f08","urls":["bzzr://d8a21d39779beb316adb5180d08dcba1941eeccd9412ff08feb21a631c18c269"]},"set-protocol-contract-utils/contracts/lib/CommonMath.sol":{"keccak256":"0x3d1d08c6efc2a973fe2c02ddcb02fd99a8c8eb75f74dcbd93e8e15864eee2b6b","urls":["bzzr://580815dd1cf648a4521d923e59087de21143d9c48115ab71579a1f5a8f3d36af"]}},"version":1}',bytecode:"0x",deployedBytecode:"0x",sourceMap:"",deployedSourceMap:"",source:'/*\n    Copyright 2018 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.7;\n\nimport { SafeMath } from "openzeppelin-solidity/contracts/math/SafeMath.sol";\nimport { CommonMath } from "set-protocol-contract-utils/contracts/lib/CommonMath.sol";\n\nimport { ExchangeHeaderLibrary } from "../../lib/ExchangeHeaderLibrary.sol";\nimport { ExchangeIssuanceLibrary } from "./ExchangeIssuanceLibrary.sol";\nimport { ExchangeWrapperLibrary } from "../../lib/ExchangeWrapperLibrary.sol";\nimport { ExchangeWrapperLibraryV2 } from "../../lib/ExchangeWrapperLibraryV2.sol";\nimport { ISetToken } from "../../interfaces/ISetToken.sol";\nimport { ModuleCoreState } from "./ModuleCoreState.sol";\n\n\n/**\n * @title ExchangeExecution\n * @author Set Protocol\n *\n * The ExchangeExecution contract exposes functions that allow validation and execution of exchange orders.\n */\ncontract ExchangeExecution is\n    ModuleCoreState\n{\n    using SafeMath for uint256;\n\n     /* ============ Private Functions ============ */\n\n    /**\n     * Execute the exchange orders by parsing the order data and facilitating the transfers. Each\n     * header represents a batch of orders for a particular exchange (0x, Kyber)\n     *\n     * @param _orderData               Bytes array containing the exchange orders to execute\n     */\n    function executeExchangeOrders(\n        bytes memory _orderData\n    )\n        internal\n    {\n        // Bitmask integer of called exchanges. Acts as a lock so that duplicate exchange headers are not passed in.\n        uint256 calledExchanges = 0;\n        \n        uint256 scannedBytes = 0;\n        while (scannedBytes < _orderData.length) {\n            // Parse exchange header based on scannedBytes\n            ExchangeHeaderLibrary.ExchangeHeader memory header = ExchangeHeaderLibrary.parseExchangeHeader(\n                _orderData,\n                scannedBytes\n            );\n\n            // Get exchange address from state mapping based on header exchange info\n            address exchangeWrapper = coreInstance.exchangeIds(header.exchange);\n\n            // Verify exchange address is registered\n            require(\n                exchangeWrapper != address(0),\n                "ExchangeExecution.executeExchangeOrders: Invalid or disabled Exchange address"\n            );\n\n            // Verify exchange has not already been called\n            uint256 exchangeBitIndex = CommonMath.safePower(2, header.exchange);\n            require(\n                (calledExchanges & exchangeBitIndex) == 0,\n                "ExchangeExecution.executeExchangeOrders: Exchange already called"\n            );\n\n            // Calculate the exchange data length\n            uint256 exchangeDataLength = header.orderDataBytesLength.add(\n                ExchangeHeaderLibrary.EXCHANGE_HEADER_LENGTH()\n            );\n\n            // Read the order body based on order data length info in header plus the length of the header\n            bytes memory bodyData = ExchangeHeaderLibrary.sliceBodyData(\n                _orderData,\n                scannedBytes,\n                exchangeDataLength\n            );\n\n            // Construct the Exchange Data struct for callExchange interface\n            ExchangeWrapperLibraryV2.ExchangeData memory exchangeData = ExchangeWrapperLibraryV2.ExchangeData({\n                caller: msg.sender,\n                orderCount: header.orderCount\n            });\n\n            // Execute orders using the appropriate exchange wrappers\n            ExchangeWrapperLibrary.callExchange(\n                core,\n                exchangeData,\n                exchangeWrapper,\n                bodyData\n            );\n\n            // Update scanned bytes with header and body lengths\n            scannedBytes = scannedBytes.add(exchangeDataLength);\n\n            // Increment bit of current exchange to ensure non-duplicate entries\n            calledExchanges = calledExchanges.add(exchangeBitIndex);\n        }\n    }\n\n    /**\n     * Calculates the user\'s balance of tokens required after exchange orders have been executed\n     *\n     * @param  _exchangeIssuanceParams       A Struct containing exchange issuance metadata\n     * @return uint256[]                     Expected token balances after order execution\n     */\n    function calculateReceiveTokenBalances(\n        ExchangeIssuanceLibrary.ExchangeIssuanceParams memory _exchangeIssuanceParams\n    )\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        // Calculate amount of receive tokens required\n        uint256[] memory requiredBalances = new uint256[](_exchangeIssuanceParams.receiveTokens.length);\n        for (uint256 i = 0; i < _exchangeIssuanceParams.receiveTokens.length; i++) {\n            // Get the user\'s current vault balances\n            uint256 tokenBalance = vaultInstance.getOwnerBalance(\n                _exchangeIssuanceParams.receiveTokens[i],\n                msg.sender\n            );\n\n            // Amount of receive tokens to be added to Vault\n            uint256 requiredAddition = _exchangeIssuanceParams.receiveTokenAmounts[i];\n\n            // Required vault balances after exchange order execution\n            requiredBalances[i] = tokenBalance.add(requiredAddition);\n        }\n\n        return requiredBalances;\n    }\n\n    /**\n     * Validates exchangeIssueParam inputs\n     *\n     * @param  _exchangeIssuanceParams       A Struct containing exchange issuance metadata\n     */\n    function validateExchangeIssuanceParams(\n        ExchangeIssuanceLibrary.ExchangeIssuanceParams memory _exchangeIssuanceParams\n    )\n        internal\n        view\n    {\n        // Verify Set was created by Core and is enabled\n        require(\n            coreInstance.validSets(_exchangeIssuanceParams.setAddress),\n            "ExchangeExecution.validateExchangeIssuanceParams: Invalid or disabled SetToken address"\n        );\n\n        // Validate the issuance quantity\n        ExchangeIssuanceLibrary.validateQuantity(\n            _exchangeIssuanceParams.setAddress,\n            _exchangeIssuanceParams.quantity\n        );\n\n        // Validate send token data\n        ExchangeIssuanceLibrary.validateSendTokenParams(\n            core,\n            _exchangeIssuanceParams.sendTokenExchangeIds,\n            _exchangeIssuanceParams.sendTokens,\n            _exchangeIssuanceParams.sendTokenAmounts\n        );\n\n        // Validate receive token inputs\n        ExchangeIssuanceLibrary.validateReceiveTokens(\n            _exchangeIssuanceParams.receiveTokens,\n            _exchangeIssuanceParams.receiveTokenAmounts\n        );\n    }\n}\n',sourcePath:"/Users/brianweickmann/Documents/Source/set-protocol-contracts/contracts/core/modules/lib/ExchangeExecution.sol",compiler:{name:"solc",version:"0.5.7+commit.6da8b019.Linux.g++"},networks:{},schemaVersion:"3.0.23",updatedAt:"2020-05-05T17:13:36.653Z",devdoc:{author:"Set Protocol * The ExchangeExecution contract exposes functions that allow validation and execution of exchange orders.",methods:{},title:"ExchangeExecution"},userdoc:{methods:{}}};
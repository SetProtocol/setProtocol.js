import { Address } from 'set-protocol-utils';
import { BigNumber } from 'bignumber.js';
import { AuctionMockContract, LinearAuctionLiquidatorContract, LinearAuctionMockContract, LiquidatorMockContract, LiquidatorProxyContract, OracleWhiteListContract, SetTokenContract, TwoAssetPriceBoundedLinearAuctionMockContract } from '../contracts';
import { LinearAuction, TokenFlow } from '../auction';
import { ERC20Helper } from './erc20Helper';
import { ValuationHelper } from './valuationHelper';
export declare class LiquidatorHelper {
    private _contractOwnerAddress;
    private _erc20Helper;
    private _valuationHelper;
    constructor(contractOwnerAddress: Address, erc20Helper: ERC20Helper, valuationHelper: ValuationHelper);
    deployAuctionMockAsync(from?: Address): Promise<AuctionMockContract>;
    deployLiquidatorProxyAsync(liquidator: Address, from?: Address): Promise<LiquidatorProxyContract>;
    deployLinearAuctionMockAsync(oracleWhiteList: Address, auctionPeriod: BigNumber, rangeStart: BigNumber, rangeEnd: BigNumber, from?: Address): Promise<LinearAuctionMockContract>;
    deployLinearAuctionLiquidatorAsync(core: Address, oracleWhiteList: Address, auctionPeriod: BigNumber, rangeStart: BigNumber, rangeEnd: BigNumber, name: string, from?: Address): Promise<LinearAuctionLiquidatorContract>;
    deployTwoAssetPriceBoundedLinearAuctionMock(oracleWhiteList: Address, auctionPeriod: BigNumber, rangeStart: BigNumber, rangeEnd: BigNumber, from?: Address): Promise<TwoAssetPriceBoundedLinearAuctionMockContract>;
    deployLiquidatorMockAsync(from?: Address): Promise<LiquidatorMockContract>;
    getBidPriceValues(setToken: SetTokenContract, quantity: BigNumber, combinedUnits: BigNumber[]): Promise<BigNumber[]>;
    constructCombinedUnitArrayAsync(setToken: SetTokenContract, combinedTokenArray: Address[], minimumBid: BigNumber): Promise<BigNumber[]>;
    calculateMinimumBidAsync(linearAuction: LinearAuction, currentSet: SetTokenContract, nextSet: SetTokenContract, assetPairPrice: BigNumber): Promise<BigNumber>;
    calculateAuctionBoundsAsync(linearAuction: LinearAuction, startBound: BigNumber, endBound: BigNumber, oracleWhiteList: OracleWhiteListContract): Promise<[BigNumber, BigNumber]>;
    calculateTwoAssetStartPrice(linearAuction: LinearAuction, assetOneFullUnit: BigNumber, assetTwoFullUnit: BigNumber, assetPairPrice: BigNumber, startBound: BigNumber): BigNumber;
    calculateTwoAssetEndPrice(linearAuction: LinearAuction, assetOneFullUnit: BigNumber, assetTwoFullUnit: BigNumber, assetPairPrice: BigNumber, endBound: BigNumber): BigNumber;
    calculateAuctionBound(linearAuction: LinearAuction, assetOneFullUnit: BigNumber, assetTwoFullUnit: BigNumber, targetPrice: BigNumber): BigNumber;
    isTokenFlowIncreasing(assetOneCurrentUnit: BigNumber, assetOneNextUnit: BigNumber, fairValue: BigNumber): boolean;
    calculateCurrentPrice(linearAuction: LinearAuction, timestamp: BigNumber, auctionPeriod: BigNumber): BigNumber;
    calculateFairValueAsync(currentSetToken: SetTokenContract, nextSetToken: SetTokenContract, oracleWhiteList: OracleWhiteListContract, from?: Address): Promise<BigNumber>;
    constructTokenFlow(linearAuction: LinearAuction, quantity: BigNumber, priceScaled: BigNumber): TokenFlow;
}

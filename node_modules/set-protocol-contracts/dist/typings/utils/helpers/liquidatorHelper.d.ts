import { Address } from 'set-protocol-utils';
import { BigNumber } from 'bignumber.js';
import { AuctionMockContract, AuctionGettersMockContract, LinearAuctionLiquidatorContract, LinearAuctionMockContract, LiquidatorMockContract, LiquidatorProxyContract, LiquidatorUtilsMockContract, OracleWhiteListContract, SetTokenContract, TWAPAuctionCallerContract, TWAPAuctionMockContract, TWAPAuctionGettersMockContract, TWAPLiquidatorContract, TwoAssetPriceBoundedLinearAuctionMockContract } from '../contracts';
import { AssetChunkSizeBounds, LinearAuction, TokenFlow } from '../auction';
import { ERC20Helper } from './erc20Helper';
import { ValuationHelper } from './valuationHelper';
export interface AuctionData {
    maxNaturalUnit: BigNumber;
    minimumBid: BigNumber;
    startTime: BigNumber;
    startingCurrentSets: BigNumber;
    remainingCurrentSets: BigNumber;
    combinedTokenArray: Address[];
    combinedCurrentSetUnits: BigNumber[];
    combinedNextSetUnits: BigNumber[];
}
export interface TestTWAPAuctionData {
    orderSize: BigNumber;
    orderRemaining: BigNumber;
    lastChunkAuctionEnd: BigNumber;
    chunkAuctionPeriod: BigNumber;
    chunkSize: BigNumber;
    remainingCurrentSets: BigNumber;
}
export declare class LiquidatorHelper {
    private _contractOwnerAddress;
    private _erc20Helper;
    private _valuationHelper;
    constructor(contractOwnerAddress: Address, erc20Helper: ERC20Helper, valuationHelper: ValuationHelper);
    deployAuctionMockAsync(from?: Address): Promise<AuctionMockContract>;
    deployAuctionGettersMockAsync(from?: Address): Promise<AuctionGettersMockContract>;
    deployTWAPAuctionGettersMockAsync(from?: Address): Promise<TWAPAuctionGettersMockContract>;
    deployTWAPAuctionCallerAsync(liquidator: Address, failAuctionPeriod?: BigNumber, from?: Address): Promise<TWAPAuctionCallerContract>;
    deployLiquidatorProxyAsync(liquidator: Address, from?: Address): Promise<LiquidatorProxyContract>;
    deployLiquidatorUtilsMockAsync(from?: Address): Promise<LiquidatorUtilsMockContract>;
    deployLinearAuctionMockAsync(oracleWhiteList: Address, auctionPeriod: BigNumber, rangeStart: BigNumber, rangeEnd: BigNumber, from?: Address): Promise<LinearAuctionMockContract>;
    deployLinearAuctionLiquidatorAsync(core: Address, oracleWhiteList: Address, auctionPeriod: BigNumber, rangeStart: BigNumber, rangeEnd: BigNumber, name: string, from?: Address): Promise<LinearAuctionLiquidatorContract>;
    deployTWAPLiquidatorAsync(core: Address, oracleWhiteList: Address, auctionPeriod: BigNumber, rangeStart: BigNumber, rangeEnd: BigNumber, assetPairHashes: string[], assetPairBounds: AssetChunkSizeBounds[], name: string, from?: Address): Promise<TWAPLiquidatorContract>;
    deployTwoAssetPriceBoundedLinearAuctionMock(oracleWhiteList: Address, auctionPeriod: BigNumber, rangeStart: BigNumber, rangeEnd: BigNumber, from?: Address): Promise<TwoAssetPriceBoundedLinearAuctionMockContract>;
    deployTWAPAuctionMock(oracleWhiteList: Address, auctionPeriod: BigNumber, rangeStart: BigNumber, rangeEnd: BigNumber, assetPairHashes: string[], assetPairBounds: AssetChunkSizeBounds[], from?: Address): Promise<TWAPAuctionMockContract>;
    deployLiquidatorMockAsync(from?: Address): Promise<LiquidatorMockContract>;
    generateTWAPLiquidatorCalldata(usdChunkSize: BigNumber, chunkAuctionPeriod: BigNumber): string;
    generateAssetPairHashes(assetOne: Address, assetTwo: Address): string;
    getBidPriceValues(setToken: SetTokenContract, quantity: BigNumber, combinedUnits: BigNumber[]): Promise<BigNumber[]>;
    constructCombinedUnitArrayAsync(setToken: SetTokenContract, combinedTokenArray: Address[], minimumBid: BigNumber): Promise<BigNumber[]>;
    calculateMinimumBidAsync(linearAuction: LinearAuction, currentSet: SetTokenContract, nextSet: SetTokenContract, assetPairPrice: BigNumber): Promise<BigNumber>;
    calculateAuctionBoundsAsync(linearAuction: LinearAuction, startBound: BigNumber, endBound: BigNumber, oracleWhiteList: OracleWhiteListContract): Promise<[BigNumber, BigNumber]>;
    calculateTwoAssetStartPrice(linearAuction: LinearAuction, assetOneFullUnit: BigNumber, assetTwoFullUnit: BigNumber, assetPairPrice: BigNumber, startBound: BigNumber): BigNumber;
    calculateTwoAssetEndPrice(linearAuction: LinearAuction, assetOneFullUnit: BigNumber, assetTwoFullUnit: BigNumber, assetPairPrice: BigNumber, endBound: BigNumber): BigNumber;
    calculateAuctionBound(linearAuction: LinearAuction, assetOneFullUnit: BigNumber, assetTwoFullUnit: BigNumber, targetPrice: BigNumber): BigNumber;
    isTokenFlowIncreasing(assetOneCurrentUnit: BigNumber, assetOneNextUnit: BigNumber, fairValue: BigNumber): boolean;
    calculateCurrentPrice(linearAuction: LinearAuction, timestamp: BigNumber, auctionPeriod: BigNumber): BigNumber;
    calculateFairValueAsync(currentSetToken: SetTokenContract, nextSetToken: SetTokenContract, oracleWhiteList: OracleWhiteListContract, from?: Address): Promise<BigNumber>;
    constructTokenFlow(linearAuction: LinearAuction, quantity: BigNumber, priceScaled: BigNumber): TokenFlow;
    calculateChunkSize(currentSet: SetTokenContract, nextSet: SetTokenContract, oracleWhiteList: OracleWhiteListContract, currentSetQuantity: BigNumber, usdChunkSize: BigNumber): Promise<BigNumber>;
    calculateChunkAuctionMaximumBid(chunkAuctionSize: BigNumber, minimumBid: BigNumber): BigNumber;
    calculateRebalanceVolumeAsync(currentSet: SetTokenContract, nextSet: SetTokenContract, oracleWhiteList: OracleWhiteListContract, currentSetQuantity: BigNumber): Promise<BigNumber>;
    calculateAssetAllocationAsync(setToken: SetTokenContract, oracleWhiteList: OracleWhiteListContract, asset: Address): Promise<BigNumber>;
}

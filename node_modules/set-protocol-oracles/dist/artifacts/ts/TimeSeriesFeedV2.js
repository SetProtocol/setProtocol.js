"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.TimeSeriesFeedV2={contractName:"TimeSeriesFeedV2",abi:[{constant:true,inputs:[],name:"nextEarliestUpdate",outputs:[{name:"",type:"uint256"}],payable:false,stateMutability:"view",type:"function"},{constant:true,inputs:[],name:"maxDataPoints",outputs:[{name:"",type:"uint256"}],payable:false,stateMutability:"view",type:"function"},{constant:true,inputs:[],name:"updateInterval",outputs:[{name:"",type:"uint256"}],payable:false,stateMutability:"view",type:"function"},{inputs:[{name:"_updateInterval",type:"uint256"},{name:"_nextEarliestUpdate",type:"uint256"},{name:"_maxDataPoints",type:"uint256"},{name:"_seededValues",type:"uint256[]"}],payable:false,stateMutability:"nonpayable",type:"constructor"},{constant:false,inputs:[],name:"poke",outputs:[],payable:false,stateMutability:"nonpayable",type:"function"},{constant:true,inputs:[{name:"_numDataPoints",type:"uint256"}],name:"read",outputs:[{name:"",type:"uint256[]"}],payable:false,stateMutability:"view",type:"function"}],metadata:'{"compiler":{"version":"0.5.7+commit.6da8b019"},"language":"Solidity","output":{"abi":[{"constant":false,"inputs":[],"name":"poke","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"nextEarliestUpdate","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"maxDataPoints","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_numDataPoints","type":"uint256"}],"name":"read","outputs":[{"name":"","type":"uint256[]"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"updateInterval","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[{"name":"_updateInterval","type":"uint256"},{"name":"_nextEarliestUpdate","type":"uint256"},{"name":"_maxDataPoints","type":"uint256"},{"name":"_seededValues","type":"uint256[]"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"}],"devdoc":{"author":"Set Protocol * Contract used to track time-series data. This is meant to be inherited, as the calculateNextValue function is unimplemented. New data is appended by calling the poke function, which retrieves the latest value using the calculateNextValue function. * CHANGELOG - Built to be inherited by contract that implements new calculateNextValue function - Uses LinkedListLibraryV3 - nextEarliestUpdate is passed into constructor","methods":{},"title":"TimeSeriesFeedV2"},"userdoc":{"methods":{}}},"settings":{"compilationTarget":{"/Users/justin_chen/Dropbox/workspace/set-protocol-oracles/contracts/meta-oracles/lib/TimeSeriesFeedV2.sol":"TimeSeriesFeedV2"},"evmVersion":"byzantium","libraries":{},"optimizer":{"enabled":true,"runs":200},"remappings":[]},"sources":{"/Users/justin_chen/Dropbox/workspace/set-protocol-oracles/contracts/meta-oracles/lib/LinkedListLibraryV3.sol":{"keccak256":"0xdcb6e24e6fe22c2fbb481df90075d9a381b9bf4cb6a83aa51bb6cb90c65cb08d","urls":["bzzr://41fa11ef9cdee0dd7563036cdf8605ac4e16e3f772d592f2b2361655284a9306"]},"/Users/justin_chen/Dropbox/workspace/set-protocol-oracles/contracts/meta-oracles/lib/TimeSeriesFeedV2.sol":{"keccak256":"0xe5cddfc8f7cce1dea5e741a08aebab62612bc6feaf60e2802af813ed0b94f92f","urls":["bzzr://52e7c979da71aeef24e8194c66f39ec4db106b7046f224ad98a3299700b0e3b1"]},"openzeppelin-solidity/contracts/math/SafeMath.sol":{"keccak256":"0xc2a200a877c4a9b2475c246c54ffecc69ffde3e11af83319c63c2dc5458bac80","urls":["bzzr://c8876e2c39b60f155d748d71d715c8f3903fae5a405ac599adcb6ad2f9a583f9"]},"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol":{"keccak256":"0x080fa336eb92fca1f96bf5c7738b6ef6e23582809d81868e9498c08e1207c125","urls":["bzzr://3bc299fd722679f1313dc1387e2efc0591dcddc3727b6a7ccc98132c6e02f323"]}},"version":1}',bytecode:"0x",deployedBytecode:"0x",sourceMap:"",deployedSourceMap:"",source:'/*\n    Copyright 2019 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.7;\npragma experimental "ABIEncoderV2";\n\nimport { ReentrancyGuard } from "openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol";\nimport { SafeMath } from "openzeppelin-solidity/contracts/math/SafeMath.sol";\n\nimport { LinkedListLibraryV3 } from "./LinkedListLibraryV3.sol";\n\n\n/**\n * @title TimeSeriesFeedV2\n * @author Set Protocol\n *\n * Contract used to track time-series data. This is meant to be inherited, as the calculateNextValue\n * function is unimplemented. New data is appended by calling the poke function, which retrieves the\n * latest value using the calculateNextValue function.\n *\n * CHANGELOG\n * - Built to be inherited by contract that implements new calculateNextValue function\n * - Uses LinkedListLibraryV3\n * - nextEarliestUpdate is passed into constructor\n */\ncontract TimeSeriesFeedV2 is\n    ReentrancyGuard\n{\n    using SafeMath for uint256;\n    using LinkedListLibraryV3 for LinkedListLibraryV3.LinkedList;\n\n    /* ============ State Variables ============ */\n    uint256 public updateInterval;\n    uint256 public maxDataPoints;\n    // Unix Timestamp in seconds of next earliest update time\n    uint256 public nextEarliestUpdate;\n\n    LinkedListLibraryV3.LinkedList internal timeSeriesData;\n\n    /* ============ Constructor ============ */\n\n    /*\n     * Stores time-series values in a LinkedList and updated using data from a specific data source. \n     * Updates must be triggered off chain to be stored in this smart contract.\n     *\n     * @param  _updateInterval            Cadence at which data is optimally logged. Optimal schedule is based\n                                          off deployment timestamp. A certain data point can\'t be logged before\n                                          it\'s expected timestamp but can be logged after \n     * @param  _nextEarliestUpdate        Time the first on-chain price update becomes available \n     * @param  _maxDataPoints             The maximum amount of data points the linkedList will hold \n     * @param  _seededValues              Array of previous timeseries values to seed initial values in list.\n     *                                    The last value should contain the most current piece of data \n     */\n    constructor(\n        uint256 _updateInterval,\n        uint256 _nextEarliestUpdate,\n        uint256 _maxDataPoints,\n        uint256[] memory _seededValues\n    )\n        public\n    {\n\n        // Check that nextEarliestUpdate is greater than current block timestamp\n        require(\n            _nextEarliestUpdate > block.timestamp,\n            "TimeSeriesFeed.constructor: nextEarliestUpdate must be greater than current timestamp."\n        );\n\n        // Check that at least one seeded value is passed in\n        require(\n            _seededValues.length > 0,\n            "TimeSeriesFeed.constructor: Must include at least one seeded value."\n        );\n\n        // Check that maxDataPoints greater than 0\n        require(\n            _maxDataPoints > 0,\n            "TimeSeriesFeed.constructor: Max data points must be greater than 0."\n        );\n\n        // Check that updateInterval greater than 0\n        require(\n            _updateInterval > 0,\n            "TimeSeriesFeed.constructor: Update interval must be greater than 0."\n        );\n\n        // Set updateInterval and maxDataPoints\n        updateInterval = _updateInterval;\n        maxDataPoints = _maxDataPoints;\n\n        // Define upper data size limit for linked list and input initial value\n        timeSeriesData.initialize(_maxDataPoints, _seededValues[0]);\n\n        // Cycle through input values array (skipping first value used to initialize LinkedList)\n        // and add to timeSeriesData\n        for (uint256 i = 1; i < _seededValues.length; i++) {\n            timeSeriesData.editList(_seededValues[i]);\n        } \n\n        // Set nextEarliestUpdate\n        nextEarliestUpdate = _nextEarliestUpdate;      \n    }\n\n    /* ============ External ============ */\n\n    /*\n     * Updates linked list with newest data point by calling the implemented calculateNextValue function\n     */\n    function poke()\n        external\n        nonReentrant\n    {\n        // Make sure block timestamp exceeds nextEarliestUpdate\n        require(\n            block.timestamp >= nextEarliestUpdate,\n            "TimeSeriesFeed.poke: Not enough time elapsed since last update"\n        );\n\n        // Get the most current data point\n        uint256 newValue = calculateNextValue();\n\n        // Update the nextEarliestUpdate to previous nextEarliestUpdate plus updateInterval\n        nextEarliestUpdate = nextEarliestUpdate.add(updateInterval);\n\n        // Update linkedList with new price\n        timeSeriesData.editList(newValue);\n    }\n\n    /*\n     * Query linked list for specified days of data. Will revert if number of days\n     * passed exceeds amount of days collected. Will revert if not enough days of\n     * data logged.\n     *\n     * @param  _numDataPoints  Number of datapoints to query\n     * @returns                Array of datapoints of length _numDataPoints from most recent to oldest                   \n     */\n    function read(\n        uint256 _numDataPoints\n    )\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return timeSeriesData.readList(_numDataPoints);\n    }\n\n\n    /* ============ Internal ============ */\n\n    function calculateNextValue()\n        internal\n        returns (uint256);\n\n}',sourcePath:"/Users/justin_chen/Dropbox/workspace/set-protocol-oracles/contracts/meta-oracles/lib/TimeSeriesFeedV2.sol",compiler:{name:"solc",version:"0.5.7+commit.6da8b019.Linux.g++"},networks:{},schemaVersion:"3.0.16",updatedAt:"2020-05-04T02:38:52.216Z",devdoc:{author:"Set Protocol * Contract used to track time-series data. This is meant to be inherited, as the calculateNextValue function is unimplemented. New data is appended by calling the poke function, which retrieves the latest value using the calculateNextValue function. * CHANGELOG - Built to be inherited by contract that implements new calculateNextValue function - Uses LinkedListLibraryV3 - nextEarliestUpdate is passed into constructor",methods:{},title:"TimeSeriesFeedV2"},userdoc:{methods:{}}};
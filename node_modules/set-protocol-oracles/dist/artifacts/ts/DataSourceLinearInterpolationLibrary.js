"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.DataSourceLinearInterpolationLibrary={contractName:"DataSourceLinearInterpolationLibrary",abi:[],metadata:'{"compiler":{"version":"0.5.7+commit.6da8b019"},"language":"Solidity","output":{"abi":[],"devdoc":{"author":"Set Protocol * Library used to determine linearly interpolated value for DataSource contracts when TimeSeriesFeed is updated after interpolationThreshold has passed.","methods":{},"title":"LinearInterpolationLibrary"},"userdoc":{"methods":{}}},"settings":{"compilationTarget":{"/Users/justin_chen/Dropbox/workspace/set-protocol-oracles/contracts/meta-oracles/lib/DataSourceLinearInterpolationLibrary.sol":"DataSourceLinearInterpolationLibrary"},"evmVersion":"byzantium","libraries":{},"optimizer":{"enabled":true,"runs":200},"remappings":[]},"sources":{"/Users/justin_chen/Dropbox/workspace/set-protocol-oracles/contracts/meta-oracles/lib/DataSourceLinearInterpolationLibrary.sol":{"keccak256":"0x65c002c6913a593201f70f58dd249b0ec2d6166159a53671c2c1a6071722a536","urls":["bzzr://91905214042e19496935d1aedb4b1125e45dca1d7e82aa6ec5ce4633820b7163"]},"openzeppelin-solidity/contracts/math/SafeMath.sol":{"keccak256":"0xc2a200a877c4a9b2475c246c54ffecc69ffde3e11af83319c63c2dc5458bac80","urls":["bzzr://c8876e2c39b60f155d748d71d715c8f3903fae5a405ac599adcb6ad2f9a583f9"]}},"version":1}',bytecode:"0x604c6023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea165627a7a723058200cc95ad726abcc2fa123d372d823db9a43411681f1fbee6d485ba20c194417c70029",deployedBytecode:"0x73000000000000000000000000000000000000000030146080604052600080fdfea165627a7a723058200cc95ad726abcc2fa123d372d823db9a43411681f1fbee6d485ba20c194417c70029",sourceMap:"930:3489:30:-;;132:2:-1;166:7;155:9;146:7;137:37;255:7;249:14;246:1;241:23;235:4;232:33;222:2;;269:9;222:2;293:9;290:1;283:20;323:4;314:7;306:22;347:7;338;331:24",deployedSourceMap:"930:3489:30:-;;;;;;;;",source:'/*\n    Copyright 2019 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.7;\n\nimport { SafeMath } from "openzeppelin-solidity/contracts/math/SafeMath.sol";\n\n\n/**\n * @title LinearInterpolationLibrary\n * @author Set Protocol\n *\n * Library used to determine linearly interpolated value for DataSource contracts when TimeSeriesFeed\n * is updated after interpolationThreshold has passed.\n */\nlibrary DataSourceLinearInterpolationLibrary {\n    using SafeMath for uint256;\n\n    /* ============ External ============ */\n\n    /*\n     * When the update time has surpassed the currentTime + interpolationThreshold, linearly interpolate the \n     * price between the current time and price and the last updated time and price to reduce potential error. This\n     * is done with the following series of equations, modified in this instance to deal unsigned integers:\n     *\n     * price = (currentPrice * updateInterval + previousLoggedPrice * timeFromExpectedUpdate) / timeFromLastUpdate \n     *\n     * Where updateTimeFraction represents the fraction of time passed between the last update and now spent in\n     * the previous update window. It\'s worth noting that because we consider updates to occur on their update\n     * timestamp we can make the assumption that the amount of time spent in the previous update window is equal\n     * to the update frequency. \n     * \n     * By way of example, assume updateInterval of 24 hours and a interpolationThreshold of 1 hour. At time 1 the\n     * update is missed by one day and when the oracle is finally called the price is 150, the price feed\n     * then interpolates this price to imply a price at t1 equal to 125. Time 2 the update is 10 minutes late but\n     * since it\'s within the interpolationThreshold the value isn\'t interpolated. At time 3 everything \n     * falls back in line.\n     *\n     * +----------------------+------+-------+-------+-------+\n     * |                      | 0    | 1     | 2     | 3     |\n     * +----------------------+------+-------+-------+-------+\n     * | Expected Update Time | 0:00 | 24:00 | 48:00 | 72:00 |\n     * +----------------------+------+-------+-------+-------+\n     * | Actual Update Time   | 0:00 | 48:00 | 48:10 | 72:00 |\n     * +----------------------+------+-------+-------+-------+\n     * | Logged Px            | 100  | 125   | 151   | 130   |\n     * +----------------------+------+-------+-------+-------+\n     * | Received Oracle Px   | 100  | 150   | 151   | 130   |\n     * +----------------------+------+-------+-------+-------+\n     * | Actual Price         | 100  | 110   | 151   | 130   |\n     * +------------------------------------------------------     \n     *\n     * @param  _currentPrice                Current price returned by oracle\n     * @param  _updateInterval              Update interval of TimeSeriesFeed\n     * @param  _timeFromExpectedUpdate      Time passed from expected update\n     * @param  _previousLoggedDataPoint     Previously logged price from TimeSeriesFeed\n     * @returns                             Interpolated price value                  \n     */\n    function interpolateDelayedPriceUpdate(\n        uint256 _currentPrice,\n        uint256 _updateInterval,\n        uint256 _timeFromExpectedUpdate,\n        uint256 _previousLoggedDataPoint\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        // Calculate how much time has passed from timestamp corresponding to last update\n        uint256 timeFromLastUpdate = _timeFromExpectedUpdate.add(_updateInterval);\n\n        // Linearly interpolate between last updated price (with corresponding timestamp) and current price (with\n        // current timestamp) to imply price at the timestamp we are updating\n        return _currentPrice.mul(_updateInterval)\n            .add(_previousLoggedDataPoint.mul(_timeFromExpectedUpdate))\n            .div(timeFromLastUpdate);      \n    }\n}',sourcePath:"/Users/justin_chen/Dropbox/workspace/set-protocol-oracles/contracts/meta-oracles/lib/DataSourceLinearInterpolationLibrary.sol",compiler:{name:"solc",version:"0.5.7+commit.6da8b019.Linux.g++"},networks:{},schemaVersion:"3.0.16",updatedAt:"2020-05-04T02:38:52.195Z",devdoc:{author:"Set Protocol * Library used to determine linearly interpolated value for DataSource contracts when TimeSeriesFeed is updated after interpolationThreshold has passed.",methods:{},title:"LinearInterpolationLibrary"},userdoc:{methods:{}}};